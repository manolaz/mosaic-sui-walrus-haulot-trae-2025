{
  "version": 3,
  "sources": ["../../src/utils.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type {\n\tDynamicFieldInfo,\n\tPaginationArguments,\n\tSuiClient,\n\tSuiObjectData,\n\tSuiObjectDataFilter,\n\tSuiObjectDataOptions,\n\tSuiObjectResponse,\n} from '@mysten/sui/client';\nimport {\n\tfromBase64,\n\tnormalizeStructTag,\n\tnormalizeSuiAddress,\n\tparseStructTag,\n} from '@mysten/sui/utils';\n\nimport { KioskType } from './bcs.js';\nimport type { Kiosk, KioskData, KioskListing, TransferPolicyCap } from './types/index.js';\nimport { TRANSFER_POLICY_CAP_TYPE } from './types/index.js';\nimport { chunk } from '@mysten/utils';\n\nconst DEFAULT_QUERY_LIMIT = 50;\n\nexport async function getKioskObject(client: SuiClient, id: string): Promise<Kiosk> {\n\tconst queryRes = await client.getObject({ id, options: { showBcs: true } });\n\n\tif (!queryRes || queryRes.error || !queryRes.data) {\n\t\tthrow new Error(`Kiosk ${id} not found; ${queryRes.error}`);\n\t}\n\n\tif (!queryRes.data.bcs || !('bcsBytes' in queryRes.data.bcs)) {\n\t\tthrow new Error(`Invalid kiosk query: ${id}, expected object, got package`);\n\t}\n\n\treturn KioskType.parse(fromBase64(queryRes.data.bcs!.bcsBytes));\n}\n\n// helper to extract kiosk data from dynamic fields.\nexport function extractKioskData(\n\tdata: DynamicFieldInfo[],\n\tlistings: KioskListing[],\n\tlockedItemIds: string[],\n\tkioskId: string,\n): KioskData {\n\treturn data.reduce<KioskData>(\n\t\t(acc: KioskData, val: DynamicFieldInfo) => {\n\t\t\tconst type = val.name.type;\n\n\t\t\tif (type.startsWith('0x2::kiosk::Item')) {\n\t\t\t\tacc.itemIds.push(val.objectId);\n\t\t\t\tacc.items.push({\n\t\t\t\t\tobjectId: val.objectId,\n\t\t\t\t\ttype: val.objectType,\n\t\t\t\t\tisLocked: false,\n\t\t\t\t\tkioskId,\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (type.startsWith('0x2::kiosk::Listing')) {\n\t\t\t\tacc.listingIds.push(val.objectId);\n\t\t\t\tlistings.push({\n\t\t\t\t\tobjectId: (val.name.value as { id: string }).id,\n\t\t\t\t\tlistingId: val.objectId,\n\t\t\t\t\tisExclusive: (val.name.value as { is_exclusive: boolean }).is_exclusive,\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (type.startsWith('0x2::kiosk::Lock')) {\n\t\t\t\tlockedItemIds?.push((val.name.value as { id: string }).id);\n\t\t\t}\n\n\t\t\tif (type.startsWith('0x2::kiosk_extension::ExtensionKey')) {\n\t\t\t\tacc.extensions.push({\n\t\t\t\t\tobjectId: val.objectId,\n\t\t\t\t\ttype: normalizeStructTag(parseStructTag(val.name.type).typeParams[0]),\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn acc;\n\t\t},\n\t\t{ items: [], itemIds: [], listingIds: [], extensions: [] },\n\t);\n}\n\n/**\n * A helper that attaches the listing prices to kiosk listings.\n */\nexport function attachListingsAndPrices(\n\tkioskData: KioskData,\n\tlistings: KioskListing[],\n\tlistingObjects: SuiObjectResponse[],\n) {\n\t// map item listings as {item_id: KioskListing}\n\t// for easier mapping on the nex\n\tconst itemListings = listings.reduce<Record<string, KioskListing>>(\n\t\t(acc: Record<string, KioskListing>, item, idx) => {\n\t\t\tacc[item.objectId] = { ...item };\n\n\t\t\t// return in case we don't have any listing objects.\n\t\t\t// that's the case when we don't have the `listingPrices` included.\n\t\t\tif (listingObjects.length === 0) return acc;\n\n\t\t\tconst content = listingObjects[idx].data?.content;\n\t\t\tconst data = content?.dataType === 'moveObject' ? content?.fields : null;\n\n\t\t\tif (!data) return acc;\n\n\t\t\tacc[item.objectId].price = (data as { value: string }).value;\n\t\t\treturn acc;\n\t\t},\n\t\t{},\n\t);\n\n\tkioskData.items.forEach((item) => {\n\t\titem.listing = itemListings[item.objectId] || undefined;\n\t});\n}\n\n/**\n * A helper that attaches the listing prices to kiosk listings.\n */\nexport function attachObjects(kioskData: KioskData, objects: SuiObjectData[]) {\n\tconst mapping = objects.reduce<Record<string, SuiObjectData>>(\n\t\t(acc: Record<string, SuiObjectData>, obj) => {\n\t\t\tacc[obj.objectId] = obj;\n\t\t\treturn acc;\n\t\t},\n\t\t{},\n\t);\n\n\tkioskData.items.forEach((item) => {\n\t\titem.data = mapping[item.objectId] || undefined;\n\t});\n}\n\n/**\n * A Helper to attach locked state to items in Kiosk Data.\n */\nexport function attachLockedItems(kioskData: KioskData, lockedItemIds: string[]) {\n\t// map lock status in an array of type { item_id: true }\n\tconst lockedStatuses = lockedItemIds.reduce<Record<string, boolean>>(\n\t\t(acc: Record<string, boolean>, item: string) => {\n\t\t\tacc[item] = true;\n\t\t\treturn acc;\n\t\t},\n\t\t{},\n\t);\n\n\t// parse lockedItemIds and attach their locked status.\n\tkioskData.items.forEach((item) => {\n\t\titem.isLocked = lockedStatuses[item.objectId] || false;\n\t});\n}\n\n/**\n * A helper to fetch all DF pages.\n * We need that to fetch the kiosk DFs consistently, until we have\n * RPC calls that allow filtering of Type / batch fetching of spec\n */\nexport async function getAllDynamicFields(\n\tclient: SuiClient,\n\tparentId: string,\n\tpagination: PaginationArguments<string>,\n) {\n\tlet hasNextPage = true;\n\tlet cursor = undefined;\n\tconst data: DynamicFieldInfo[] = [];\n\n\twhile (hasNextPage) {\n\t\tconst result = await client.getDynamicFields({\n\t\t\tparentId,\n\t\t\tlimit: pagination.limit || undefined,\n\t\t\tcursor,\n\t\t});\n\t\tdata.push(...result.data);\n\t\thasNextPage = result.hasNextPage;\n\t\tcursor = result.nextCursor;\n\t}\n\n\treturn data;\n}\n\n/**\n * A helper to fetch all objects that works with pagination.\n * It will fetch all objects in the array, and limit it to 50/request.\n * Requests are sent using `Promise.all`.\n */\nexport async function getAllObjects(\n\tclient: SuiClient,\n\tids: string[],\n\toptions: SuiObjectDataOptions,\n\tlimit: number = DEFAULT_QUERY_LIMIT,\n) {\n\tconst chunks = chunk(ids, limit);\n\n\tconst results = await Promise.all(\n\t\tchunks.map((chunk) => {\n\t\t\treturn client.multiGetObjects({\n\t\t\t\tids: chunk,\n\t\t\t\toptions,\n\t\t\t});\n\t\t}),\n\t);\n\n\treturn results.flat();\n}\n\n/**\n * A helper to return all owned objects, with an optional filter.\n * It parses all the pages and returns the data.\n */\nexport async function getAllOwnedObjects({\n\tclient,\n\towner,\n\tfilter,\n\tlimit = DEFAULT_QUERY_LIMIT,\n\toptions = { showType: true, showContent: true },\n}: {\n\tclient: SuiClient;\n\towner: string;\n\tfilter?: SuiObjectDataFilter;\n\toptions?: SuiObjectDataOptions;\n\tlimit?: number;\n}) {\n\tlet hasNextPage = true;\n\tlet cursor = undefined;\n\tconst data: SuiObjectResponse[] = [];\n\n\twhile (hasNextPage) {\n\t\tconst result = await client.getOwnedObjects({\n\t\t\towner,\n\t\t\tfilter,\n\t\t\tlimit,\n\t\t\tcursor,\n\t\t\toptions,\n\t\t});\n\t\tdata.push(...result.data);\n\t\thasNextPage = result.hasNextPage;\n\t\tcursor = result.nextCursor;\n\t}\n\n\treturn data;\n}\n\n/**\n * Converts a number to basis points.\n * Supports up to 2 decimal points.\n * E.g 9.95 -> 995\n * @param percentage A percentage amount in the range [0, 100] including decimals.\n */\nexport function percentageToBasisPoints(percentage: number) {\n\tif (percentage < 0 || percentage > 100)\n\t\tthrow new Error('Percentage needs to be in the [0,100] range.');\n\treturn Math.ceil(percentage * 100);\n}\n\n/**\n * A helper to parse a transfer policy Cap into a usable object.\n */\nexport function parseTransferPolicyCapObject(\n\titem: SuiObjectResponse,\n): TransferPolicyCap | undefined {\n\tconst type = (item?.data?.content as { type: string })?.type;\n\n\t//@ts-ignore-next-line\n\tconst policy = item?.data?.content?.fields?.policy_id as string;\n\n\tif (!type.includes(TRANSFER_POLICY_CAP_TYPE)) return undefined;\n\n\t// Transform 0x2::transfer_policy::TransferPolicyCap<itemType> -> itemType\n\tconst objectType = type.replace(TRANSFER_POLICY_CAP_TYPE + '<', '').slice(0, -1);\n\n\treturn {\n\t\tpolicyId: policy,\n\t\tpolicyCapId: item.data?.objectId!,\n\t\ttype: objectType,\n\t};\n}\n\n// Normalizes the packageId part of a rule's type.\nexport function getNormalizedRuleType(rule: string) {\n\tconst normalizedRuleAddress = rule.split('::');\n\tnormalizedRuleAddress[0] = normalizeSuiAddress(normalizedRuleAddress[0]);\n\treturn normalizedRuleAddress.join('::');\n}\n"],
  "mappings": "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",
  "names": ["import_utils", "chunk"]
}
