"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var resolve_exports = {};
__export(resolve_exports, {
  resolveFloorPriceRule: () => resolveFloorPriceRule,
  resolveKioskLockRule: () => resolveKioskLockRule,
  resolvePersonalKioskRule: () => resolvePersonalKioskRule,
  resolveRoyaltyRule: () => resolveRoyaltyRule
});
module.exports = __toCommonJS(resolve_exports);
var import_bcs = require("@mysten/sui/bcs");
var import_transactions = require("@mysten/sui/transactions");
var import_utils = require("@mysten/sui/utils");
var import_kiosk = require("../kiosk.js");
async function resolveRoyaltyRule(params) {
  const {
    kioskClient,
    transaction: tx,
    itemType,
    price,
    packageId,
    transferRequest,
    policyId
  } = params;
  const feeTx = new import_transactions.Transaction();
  feeTx.moveCall({
    target: `${packageId}::royalty_rule::fee_amount`,
    typeArguments: [itemType],
    arguments: [feeTx.object(policyId), feeTx.pure.u64(price || "0")]
  });
  const policyObj = tx.object(policyId);
  const { results } = await kioskClient.client.devInspectTransactionBlock({
    sender: tx.getData().sender || (0, import_utils.normalizeSuiAddress)("0x0"),
    transactionBlock: feeTx
  });
  let amount = null;
  if (results) {
    const returnedAmount = results?.[0].returnValues?.[0]?.[0];
    if (returnedAmount) {
      amount = BigInt(import_bcs.bcs.U64.parse(new Uint8Array(returnedAmount)));
    }
  }
  if (!amount) {
    [amount] = tx.moveCall({
      target: `${packageId}::royalty_rule::fee_amount`,
      typeArguments: [itemType],
      arguments: [policyObj, tx.pure.u64(price || "0")]
    });
  }
  const feeCoin = tx.splitCoins(tx.gas, [amount]);
  tx.moveCall({
    target: `${packageId}::royalty_rule::pay`,
    typeArguments: [itemType],
    arguments: [policyObj, transferRequest, feeCoin]
  });
}
function resolveKioskLockRule(params) {
  const {
    transaction: tx,
    packageId,
    itemType,
    kiosk,
    kioskCap,
    policyId,
    purchasedItem,
    transferRequest
  } = params;
  if (!kiosk || !kioskCap) throw new Error("Missing Owned Kiosk or Owned Kiosk Cap");
  (0, import_kiosk.lock)(tx, itemType, kiosk, kioskCap, policyId, purchasedItem);
  tx.moveCall({
    target: `${packageId}::kiosk_lock_rule::prove`,
    typeArguments: [itemType],
    arguments: [transferRequest, tx.object(kiosk)]
  });
}
function resolvePersonalKioskRule(params) {
  const { transaction: tx, packageId, itemType, kiosk, transferRequest } = params;
  if (!kiosk) throw new Error("Missing owned Kiosk.");
  tx.moveCall({
    target: `${packageId}::personal_kiosk_rule::prove`,
    typeArguments: [itemType],
    arguments: [tx.object(kiosk), transferRequest]
  });
}
function resolveFloorPriceRule(params) {
  const { transaction: tx, packageId, itemType, policyId, transferRequest } = params;
  tx.moveCall({
    target: `${packageId}::floor_price_rule::prove`,
    typeArguments: [itemType],
    arguments: [tx.object(policyId), transferRequest]
  });
}
//# sourceMappingURL=resolve.js.map
