{
  "version": 3,
  "sources": ["../../../src/client/kiosk-transaction.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type {\n\tTransaction,\n\tTransactionArgument,\n\tTransactionObjectArgument,\n} from '@mysten/sui/transactions';\n\nimport * as kioskTx from '../tx/kiosk.js';\nimport { convertToPersonalTx, transferPersonalCapTx } from '../tx/personal-kiosk.js';\nimport { confirmRequest } from '../tx/transfer-policy.js';\nimport type {\n\tItemId,\n\tItemReference,\n\tItemValue,\n\tKioskOwnerCap,\n\tObjectArgument,\n\tPrice,\n\tPurchaseOptions,\n} from '../types/index.js';\nimport { getNormalizedRuleType } from '../utils.js';\nimport type { KioskClient } from './kiosk-client.js';\n\nexport type KioskTransactionParams = {\n\t/** The Transaction for this run */\n\ttransaction: Transaction;\n\n\t/** @deprecated use transaction instead */\n\ttransactionBlock?: Transaction;\n\t/**\n\t * You can create a new KioskClient by calling `new KioskClient()`\n\t */\n\tkioskClient: KioskClient;\n\t/**\n\t * You can optionally pass in the `cap` as returned\n\t * from `kioskClient.getOwnedKiosks` when initializing the client\n\t * Otherwise, you can set it by calling `kioskTransaction.setCap()`\n\t */\n\tcap?: KioskOwnerCap;\n};\n\n/**\n * A helper for building transactions that involve kiosk.\n */\nexport class KioskTransaction {\n\ttransaction: Transaction;\n\tkioskClient: KioskClient;\n\tkiosk?: TransactionObjectArgument;\n\tkioskCap?: TransactionObjectArgument;\n\t// If we're pending `share` of a new kiosk, `finalize()` will share it.\n\t#pendingShare?: boolean;\n\t// If we're pending transferring of the cap, `finalize()` will either error or transfer the cap if it's a new personal.\n\t#pendingTransfer?: boolean;\n\t// The promise that the personalCap will be returned on `finalize()`.\n\t#promise?: TransactionArgument | undefined;\n\t// The personal kiosk argument.\n\t#personalCap?: TransactionObjectArgument;\n\t// A flag that checks whether kiosk TX is finalized.\n\t#finalized: boolean = false;\n\n\tconstructor({\n\t\ttransactionBlock,\n\t\ttransaction = transactionBlock!,\n\t\tkioskClient,\n\t\tcap,\n\t}: KioskTransactionParams) {\n\t\tthis.transaction = transaction;\n\t\tthis.kioskClient = kioskClient;\n\n\t\tif (cap) this.setCap(cap);\n\t}\n\n\t/**\n\t * Creates a kiosk and saves `kiosk` and `kioskOwnerCap` in state.\n\t * Helpful if we want to chain some actions before sharing + transferring the cap to the specified address.\n\t * @param borrow If true, the `kioskOwnerCap` is borrowed from the `PersonalKioskCap` to be used in next transactions.\n\t */\n\tcreate() {\n\t\tthis.#validateFinalizedStatus();\n\t\tthis.#setPendingStatuses({\n\t\t\tshare: true,\n\t\t\ttransfer: true,\n\t\t});\n\t\tconst [kiosk, cap] = kioskTx.createKiosk(this.transaction);\n\t\tthis.kiosk = kiosk;\n\t\tthis.kioskCap = cap;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Creates a personal kiosk & shares it.\n\t * The `PersonalKioskCap` is transferred to the signer.\n\t * @param borrow If true, the `kioskOwnerCap` is borrowed from the `PersonalKioskCap` to be used in next transactions.\n\t */\n\tcreatePersonal(borrow?: boolean) {\n\t\tthis.#pendingShare = true;\n\t\treturn this.create().convertToPersonal(borrow);\n\t}\n\n\t/**\n\t * Converts a kiosk to a Personal (Soulbound) Kiosk.\n\t * Requires initialization by either calling `ktxb.create()` or `ktxb.setCap()`.\n\t */\n\tconvertToPersonal(borrow?: boolean) {\n\t\tthis.#validateKioskIsSet();\n\n\t\tconst cap = convertToPersonalTx(\n\t\t\tthis.transaction,\n\t\t\tthis.kiosk!,\n\t\t\tthis.kioskCap!,\n\t\t\tthis.kioskClient.getRulePackageId('personalKioskRulePackageId'),\n\t\t);\n\n\t\t// if we enable `borrow`, we borrow the kioskCap from the cap.\n\t\tif (borrow) this.#borrowFromPersonalCap(cap);\n\t\telse this.#personalCap = cap;\n\n\t\tthis.#setPendingStatuses({ transfer: true });\n\t\treturn this;\n\t}\n\n\t/**\n\t * Single function way to create a kiosk, share it and transfer the cap to the specified address.\n\t */\n\tcreateAndShare(address: string) {\n\t\tthis.#validateFinalizedStatus();\n\t\tconst cap = kioskTx.createKioskAndShare(this.transaction);\n\t\tthis.transaction.transferObjects([cap], this.transaction.pure.address(address));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Shares the kiosk.\n\t */\n\tshare() {\n\t\tthis.#validateKioskIsSet();\n\t\tthis.#setPendingStatuses({ share: false });\n\t\tkioskTx.shareKiosk(this.transaction, this.kiosk!);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Should be called only after `create` is called.\n\t * It shares the kiosk & transfers the cap to the specified address.\n\t */\n\tshareAndTransferCap(address: string) {\n\t\tif (this.#personalCap)\n\t\t\tthrow new Error('You can only call `shareAndTransferCap` on a non-personal kiosk.');\n\t\tthis.#setPendingStatuses({ transfer: false });\n\t\tthis.share();\n\t\tthis.transaction.transferObjects([this.kioskCap!], this.transaction.pure.address(address));\n\t\treturn this;\n\t}\n\n\t/**\n\t * A function to borrow an item from a kiosk & execute any function with it.\n\t * Example: You could borrow a Fren out of a kiosk, attach an accessory (or mix), and return it.\n\t */\n\tborrowTx({ itemType, itemId }: ItemId, callback: (item: TransactionArgument) => void) {\n\t\tthis.#validateKioskIsSet();\n\t\tconst [itemObj, promise] = kioskTx.borrowValue(\n\t\t\tthis.transaction,\n\t\t\titemType,\n\t\t\tthis.kiosk!,\n\t\t\tthis.kioskCap!,\n\t\t\titemId,\n\t\t);\n\n\t\tcallback(itemObj);\n\n\t\treturn this.return({ itemType, item: itemObj, promise });\n\t}\n\n\t/**\n\t * Borrows an item from the kiosk.\n\t * This will fail if the item is listed for sale.\n\t *\n\t * Requires calling `return`.\n\t */\n\tborrow({ itemType, itemId }: ItemId): [TransactionArgument, TransactionArgument] {\n\t\tthis.#validateKioskIsSet();\n\t\tconst [itemObj, promise] = kioskTx.borrowValue(\n\t\t\tthis.transaction,\n\t\t\titemType,\n\t\t\tthis.kiosk!,\n\t\t\tthis.kioskCap!,\n\t\t\titemId,\n\t\t);\n\n\t\treturn [itemObj, promise];\n\t}\n\n\t/**\n\t * Returns the item back to the kiosk.\n\t * Accepts the parameters returned from the `borrow` function.\n\t */\n\treturn({ itemType, item, promise }: ItemValue & { promise: TransactionArgument }) {\n\t\tthis.#validateKioskIsSet();\n\t\tkioskTx.returnValue(this.transaction, itemType, this.kiosk!, item, promise);\n\t\treturn this;\n\t}\n\n\t/**\n\t * A function to withdraw from kiosk\n\t * @param address Where to trasnfer the coin.\n\t * @param amount The amount we aim to withdraw.\n\t */\n\twithdraw(address: string, amount?: string | bigint | number) {\n\t\tthis.#validateKioskIsSet();\n\t\tconst coin = kioskTx.withdrawFromKiosk(this.transaction, this.kiosk!, this.kioskCap!, amount);\n\t\tthis.transaction.transferObjects([coin], this.transaction.pure.address(address));\n\t\treturn this;\n\t}\n\n\t/**\n\t * A function to place an item in the kiosk.\n\t * @param itemType The type `T` of the item\n\t * @param item The ID or Transaction Argument of the item\n\t */\n\tplace({ itemType, item }: ItemReference) {\n\t\tthis.#validateKioskIsSet();\n\t\tkioskTx.place(this.transaction, itemType, this.kiosk!, this.kioskCap!, item);\n\t\treturn this;\n\t}\n\n\t/**\n\t * A function to place an item in the kiosk and list it for sale in one transaction.\n\t * @param itemType The type `T` of the item\n\t * @param item The ID or Transaction Argument of the item\n\t * @param price The price in MIST\n\t */\n\tplaceAndList({ itemType, item, price }: ItemReference & Price) {\n\t\tthis.#validateKioskIsSet();\n\t\tkioskTx.placeAndList(this.transaction, itemType, this.kiosk!, this.kioskCap!, item, price);\n\t\treturn this;\n\t}\n\n\t/**\n\t * A function to list an item in the kiosk.\n\t * @param itemType The type `T` of the item\n\t * @param itemId The ID of the item\n\t * @param price The price in MIST\n\t */\n\tlist({ itemType, itemId, price }: ItemId & { price: string | bigint }) {\n\t\tthis.#validateKioskIsSet();\n\t\tkioskTx.list(this.transaction, itemType, this.kiosk!, this.kioskCap!, itemId, price);\n\t\treturn this;\n\t}\n\n\t/**\n\t * A function to delist an item from the kiosk.\n\t * @param itemType The type `T` of the item\n\t * @param itemId The ID of the item\n\t */\n\tdelist({ itemType, itemId }: ItemId) {\n\t\tthis.#validateKioskIsSet();\n\t\tkioskTx.delist(this.transaction, itemType, this.kiosk!, this.kioskCap!, itemId);\n\t\treturn this;\n\t}\n\n\t/**\n\t * A function to take an item from the kiosk. The transaction won't succeed if the item is listed or locked.\n\n\t * @param itemType The type `T` of the item\n\t * @param itemId The ID of the item\n\t */\n\ttake({ itemType, itemId }: ItemId): TransactionObjectArgument {\n\t\tthis.#validateKioskIsSet();\n\t\treturn kioskTx.take(this.transaction, itemType, this.kiosk!, this.kioskCap!, itemId);\n\t}\n\n\t/**\n\t * Transfer a non-locked/non-listed item to an address.\n\t *\n\t * @param itemType The type `T` of the item\n\t * @param itemId The ID of the item\n\t * @param address The destination address\n\t */\n\ttransfer({ itemType, itemId, address }: ItemId & { address: string }) {\n\t\tthis.#validateKioskIsSet();\n\t\tconst item = this.take({ itemType, itemId });\n\t\tthis.transaction.transferObjects([item], this.transaction.pure.address(address));\n\t\treturn this;\n\t}\n\n\t/**\n\t * A function to take lock an item in the kiosk.\n\n\t * @param itemType The type `T` of the item\n\t * @param item The ID or Transaction Argument of the item\n\t * @param itemId The ID of the item - Deprecated: Use `item` instead.\n\t * @param policy The Policy ID or Transaction Argument for item T\n\t */\n\tlock({\n\t\titemType,\n\t\titem,\n\t\titemId,\n\t\tpolicy,\n\t}: ItemReference & { policy: ObjectArgument; itemId?: string }) {\n\t\tthis.#validateKioskIsSet();\n\t\tkioskTx.lock(this.transaction, itemType, this.kiosk!, this.kioskCap!, policy, itemId ?? item);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Purchase an item from a seller's kiosk.\n\t * Returns [item, transferRequest]\n\t * Can be called like: `const [item, transferRequest] = kioskTx.purchase({...})`\n\t * @param itemType The type `T` of the item\n\t * @param itemId The ID of the item\n\t * @param price The price in MIST\n\t * @param sellerKiosk The kiosk which is selling the item. Can be an id or an object argument.\n\t */\n\tpurchase({\n\t\titemType,\n\t\titemId,\n\t\tprice,\n\t\tsellerKiosk,\n\t}: ItemId & Price & { sellerKiosk: ObjectArgument }): [\n\t\tTransactionObjectArgument,\n\t\tTransactionObjectArgument,\n\t] {\n\t\t// Split the coin for the amount of the listing.\n\t\tconst coin = this.transaction.splitCoins(this.transaction.gas, [\n\t\t\tthis.transaction.pure.u64(price),\n\t\t]);\n\t\treturn kioskTx.purchase(this.transaction, itemType, sellerKiosk, itemId, coin);\n\t}\n\n\t/**\n\t * A function to purchase and resolve a transfer policy.\n\t * If the transfer policy has the `lock` rule, the item is locked in the kiosk.\n\t * Otherwise, the item is placed in the kiosk.\n\t * @param itemType The type of the item\n\t * @param itemId The id of the item\n\t * @param price The price of the specified item\n\t * @param sellerKiosk The kiosk which is selling the item. Can be an id or an object argument.\n\t * @param extraArgs Used to pass arguments for custom rule resolvers.\n\t */\n\tasync purchaseAndResolve({\n\t\titemType,\n\t\titemId,\n\t\tprice,\n\t\tsellerKiosk,\n\t\textraArgs,\n\t}: ItemId & Price & { sellerKiosk: ObjectArgument } & PurchaseOptions) {\n\t\tthis.#validateKioskIsSet();\n\t\t// Get a list of the transfer policies.\n\t\tconst policies = await this.kioskClient.getTransferPolicies({ type: itemType });\n\n\t\tif (policies.length === 0) {\n\t\t\tthrow new Error(\n\t\t\t\t`The type ${itemType} doesn't have a Transfer Policy so it can't be traded through kiosk.`,\n\t\t\t);\n\t\t}\n\n\t\tconst policy = policies[0]; // we now pick the first one. We need to add an option to define which one.\n\n\t\t// initialize the purchase `kiosk::purchase`\n\t\tconst [purchasedItem, transferRequest] = this.purchase({\n\t\t\titemType,\n\t\t\titemId,\n\t\t\tprice,\n\t\t\tsellerKiosk,\n\t\t});\n\n\t\tlet canTransferOutsideKiosk = true;\n\n\t\tfor (const rule of policy.rules) {\n\t\t\tconst ruleDefinition = this.kioskClient.rules.find(\n\t\t\t\t(x) => getNormalizedRuleType(x.rule) === getNormalizedRuleType(rule),\n\t\t\t);\n\t\t\tif (!ruleDefinition) throw new Error(`No resolver for the following rule: ${rule}.`);\n\n\t\t\tif (ruleDefinition.hasLockingRule) canTransferOutsideKiosk = false;\n\n\t\t\tawait ruleDefinition.resolveRuleFunction({\n\t\t\t\tpackageId: ruleDefinition.packageId,\n\t\t\t\ttransactionBlock: this.transaction,\n\t\t\t\ttransaction: this.transaction,\n\t\t\t\titemType,\n\t\t\t\titemId,\n\t\t\t\tprice: price.toString(),\n\t\t\t\tsellerKiosk,\n\t\t\t\tpolicyId: policy.id,\n\t\t\t\ttransferRequest,\n\t\t\t\tpurchasedItem,\n\t\t\t\tkiosk: this.kiosk!,\n\t\t\t\tkioskCap: this.kioskCap!,\n\t\t\t\textraArgs: extraArgs || {},\n\t\t\t\tkioskClient: this.kioskClient,\n\t\t\t});\n\t\t}\n\n\t\tconfirmRequest(this.transaction, itemType, policy.id, transferRequest);\n\n\t\tif (canTransferOutsideKiosk) this.place({ itemType, item: purchasedItem });\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * A function to setup the client using an existing `ownerCap`,\n\t * as return from the `kioskClient.getOwnedKiosks` function.\n\t * @param cap `KioskOwnerCap` object as returned from `getOwnedKiosks` SDK call.\n\t */\n\tsetCap(cap: KioskOwnerCap) {\n\t\tthis.#validateFinalizedStatus();\n\t\tthis.kiosk = this.transaction.object(cap.kioskId);\n\t\tif (!cap.isPersonal) {\n\t\t\tthis.kioskCap = this.transaction.object(cap.objectId);\n\t\t\treturn;\n\t\t}\n\n\t\treturn this.#borrowFromPersonalCap(cap.objectId);\n\t}\n\n\t/**\n\t *\tA function that ends up the kiosk building tx & returns the `kioskOwnerCap` back to the\n\t *  `PersonalKioskCap`, in case we are operating on a personal kiosk.\n\t * \tIt will also share the `kiosk` if it's not shared, and finalize the transfer of the personal cap if it's pending.\n\t */\n\tfinalize() {\n\t\tthis.#validateKioskIsSet();\n\t\t// If we're pending the sharing of the new kiosk, share it.\n\t\tif (this.#pendingShare) this.share();\n\n\t\t// If we're operating on a non-personal kiosk, we don't need to do anything else.\n\t\tif (!this.#personalCap) {\n\t\t\t// If we're pending transfer though, we inform user to call `shareAndTransferCap()`.\n\t\t\tif (this.#pendingTransfer)\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'You need to transfer the `kioskOwnerCap` by calling `shareAndTransferCap()` before wrap',\n\t\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\tconst packageId = this.kioskClient.getRulePackageId('personalKioskRulePackageId');\n\n\t\t// if we have a promise, return the `ownerCap` back to the personal cap.\n\t\tif (this.#promise) {\n\t\t\tthis.transaction.moveCall({\n\t\t\t\ttarget: `${packageId}::personal_kiosk::return_val`,\n\t\t\t\targuments: [this.#personalCap, this.transaction.object(this.kioskCap!), this.#promise!],\n\t\t\t});\n\t\t}\n\n\t\t// If we are pending transferring the personalCap, we do it here.\n\t\tif (this.#pendingTransfer)\n\t\t\ttransferPersonalCapTx(this.transaction, this.#personalCap, packageId);\n\n\t\t// Mark the transaction as finalized, so no other functions can be called.\n\t\tthis.#finalized = true;\n\t}\n\n\t// Some setters in case we want custom behavior.\n\tsetKioskCap(cap: TransactionObjectArgument) {\n\t\tthis.#validateFinalizedStatus();\n\t\tthis.kioskCap = cap;\n\t\treturn this;\n\t}\n\n\tsetKiosk(kiosk: TransactionObjectArgument) {\n\t\tthis.#validateFinalizedStatus();\n\t\tthis.kiosk = kiosk;\n\t\treturn this;\n\t}\n\n\t// Some getters\n\t/*\n\t * Returns the active transaction's kiosk, or undefined if `setCap` or `create()` hasn't been called yet.\n\t */\n\tgetKiosk() {\n\t\tthis.#validateFinalizedStatus();\n\t\tif (!this.kiosk) throw new Error('Kiosk is not set.');\n\t\treturn this.kiosk;\n\t}\n\n\t/*\n\t * Returns the active transaction's kioskOwnerCap, or undefined if `setCap` or `create()` hasn't been called yet.\n\t */\n\tgetKioskCap() {\n\t\tthis.#validateFinalizedStatus();\n\t\tif (!this.kioskCap) throw new Error('Kiosk cap is not set');\n\t\treturn this.kioskCap;\n\t}\n\n\t/**\n\t * A function to borrow from `personalCap`.\n\t */\n\t#borrowFromPersonalCap(personalCap: ObjectArgument) {\n\t\tconst [kioskCap, promise] = this.transaction.moveCall({\n\t\t\ttarget: `${this.kioskClient.getRulePackageId(\n\t\t\t\t'personalKioskRulePackageId',\n\t\t\t)}::personal_kiosk::borrow_val`,\n\t\t\targuments: [this.transaction.object(personalCap)],\n\t\t});\n\n\t\tthis.kioskCap = kioskCap;\n\t\tthis.#personalCap = this.transaction.object(personalCap);\n\t\tthis.#promise = promise;\n\n\t\treturn this;\n\t}\n\n\t#setPendingStatuses({ share, transfer }: { share?: boolean; transfer?: boolean }) {\n\t\tif (transfer !== undefined) this.#pendingTransfer = transfer;\n\t\tif (share !== undefined) this.#pendingShare = share;\n\t}\n\n\t#validateKioskIsSet() {\n\t\tthis.#validateFinalizedStatus();\n\n\t\tif (!this.kiosk || !this.kioskCap)\n\t\t\tthrow new Error(\n\t\t\t\t'You need to initialize the client by either supplying an existing owner cap or by creating a new by calling `.create()`',\n\t\t\t);\n\t}\n\n\t// Validates that `finalize`\n\t#validateFinalizedStatus() {\n\t\tif (this.#finalized)\n\t\t\tthrow new Error(\"You can't add more transactions to a finalized kiosk transaction.\");\n\t}\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AASA,cAAyB;AACzB,4BAA2D;AAC3D,6BAA+B;AAU/B,mBAAsC;AArBtC;AA6CO,MAAM,iBAAiB;AAAA,EAgB7B,YAAY;AAAA,IACX;AAAA,IACA,cAAc;AAAA,IACd;AAAA,IACA;AAAA,EACD,GAA2B;AArBrB;AAMN;AAAA;AAEA;AAAA;AAEA;AAAA;AAEA;AAAA;AAEA;AAAA,mCAAsB;AAQrB,SAAK,cAAc;AACnB,SAAK,cAAc;AAEnB,QAAI,IAAK,MAAK,OAAO,GAAG;AAAA,EACzB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,SAAS;AACR,0BAAK,yDAAL;AACA,0BAAK,oDAAL,WAAyB;AAAA,MACxB,OAAO;AAAA,MACP,UAAU;AAAA,IACX;AACA,UAAM,CAAC,OAAO,GAAG,IAAI,QAAQ,YAAY,KAAK,WAAW;AACzD,SAAK,QAAQ;AACb,SAAK,WAAW;AAChB,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,eAAe,QAAkB;AAChC,uBAAK,eAAgB;AACrB,WAAO,KAAK,OAAO,EAAE,kBAAkB,MAAM;AAAA,EAC9C;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,kBAAkB,QAAkB;AACnC,0BAAK,oDAAL;AAEA,UAAM,UAAM;AAAA,MACX,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK,YAAY,iBAAiB,4BAA4B;AAAA,IAC/D;AAGA,QAAI,OAAQ,uBAAK,uDAAL,WAA4B;AAAA,QACnC,oBAAK,cAAe;AAEzB,0BAAK,oDAAL,WAAyB,EAAE,UAAU,KAAK;AAC1C,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA,EAKA,eAAe,SAAiB;AAC/B,0BAAK,yDAAL;AACA,UAAM,MAAM,QAAQ,oBAAoB,KAAK,WAAW;AACxD,SAAK,YAAY,gBAAgB,CAAC,GAAG,GAAG,KAAK,YAAY,KAAK,QAAQ,OAAO,CAAC;AAC9E,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA,EAKA,QAAQ;AACP,0BAAK,oDAAL;AACA,0BAAK,oDAAL,WAAyB,EAAE,OAAO,MAAM;AACxC,YAAQ,WAAW,KAAK,aAAa,KAAK,KAAM;AAChD,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,oBAAoB,SAAiB;AACpC,QAAI,mBAAK;AACR,YAAM,IAAI,MAAM,kEAAkE;AACnF,0BAAK,oDAAL,WAAyB,EAAE,UAAU,MAAM;AAC3C,SAAK,MAAM;AACX,SAAK,YAAY,gBAAgB,CAAC,KAAK,QAAS,GAAG,KAAK,YAAY,KAAK,QAAQ,OAAO,CAAC;AACzF,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,SAAS,EAAE,UAAU,OAAO,GAAW,UAA+C;AACrF,0BAAK,oDAAL;AACA,UAAM,CAAC,SAAS,OAAO,IAAI,QAAQ;AAAA,MAClC,KAAK;AAAA,MACL;AAAA,MACA,KAAK;AAAA,MACL,KAAK;AAAA,MACL;AAAA,IACD;AAEA,aAAS,OAAO;AAEhB,WAAO,KAAK,OAAO,EAAE,UAAU,MAAM,SAAS,QAAQ,CAAC;AAAA,EACxD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,OAAO,EAAE,UAAU,OAAO,GAAuD;AAChF,0BAAK,oDAAL;AACA,UAAM,CAAC,SAAS,OAAO,IAAI,QAAQ;AAAA,MAClC,KAAK;AAAA,MACL;AAAA,MACA,KAAK;AAAA,MACL,KAAK;AAAA,MACL;AAAA,IACD;AAEA,WAAO,CAAC,SAAS,OAAO;AAAA,EACzB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,OAAO,EAAE,UAAU,MAAM,QAAQ,GAAiD;AACjF,0BAAK,oDAAL;AACA,YAAQ,YAAY,KAAK,aAAa,UAAU,KAAK,OAAQ,MAAM,OAAO;AAC1E,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,SAAS,SAAiB,QAAmC;AAC5D,0BAAK,oDAAL;AACA,UAAM,OAAO,QAAQ,kBAAkB,KAAK,aAAa,KAAK,OAAQ,KAAK,UAAW,MAAM;AAC5F,SAAK,YAAY,gBAAgB,CAAC,IAAI,GAAG,KAAK,YAAY,KAAK,QAAQ,OAAO,CAAC;AAC/E,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,EAAE,UAAU,KAAK,GAAkB;AACxC,0BAAK,oDAAL;AACA,YAAQ,MAAM,KAAK,aAAa,UAAU,KAAK,OAAQ,KAAK,UAAW,IAAI;AAC3E,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,aAAa,EAAE,UAAU,MAAM,MAAM,GAA0B;AAC9D,0BAAK,oDAAL;AACA,YAAQ,aAAa,KAAK,aAAa,UAAU,KAAK,OAAQ,KAAK,UAAW,MAAM,KAAK;AACzF,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,KAAK,EAAE,UAAU,QAAQ,MAAM,GAAwC;AACtE,0BAAK,oDAAL;AACA,YAAQ,KAAK,KAAK,aAAa,UAAU,KAAK,OAAQ,KAAK,UAAW,QAAQ,KAAK;AACnF,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,OAAO,EAAE,UAAU,OAAO,GAAW;AACpC,0BAAK,oDAAL;AACA,YAAQ,OAAO,KAAK,aAAa,UAAU,KAAK,OAAQ,KAAK,UAAW,MAAM;AAC9E,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,KAAK,EAAE,UAAU,OAAO,GAAsC;AAC7D,0BAAK,oDAAL;AACA,WAAO,QAAQ,KAAK,KAAK,aAAa,UAAU,KAAK,OAAQ,KAAK,UAAW,MAAM;AAAA,EACpF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,SAAS,EAAE,UAAU,QAAQ,QAAQ,GAAiC;AACrE,0BAAK,oDAAL;AACA,UAAM,OAAO,KAAK,KAAK,EAAE,UAAU,OAAO,CAAC;AAC3C,SAAK,YAAY,gBAAgB,CAAC,IAAI,GAAG,KAAK,YAAY,KAAK,QAAQ,OAAO,CAAC;AAC/E,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,KAAK;AAAA,IACJ;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACD,GAAgE;AAC/D,0BAAK,oDAAL;AACA,YAAQ,KAAK,KAAK,aAAa,UAAU,KAAK,OAAQ,KAAK,UAAW,QAAQ,UAAU,IAAI;AAC5F,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,SAAS;AAAA,IACR;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACD,GAGE;AAED,UAAM,OAAO,KAAK,YAAY,WAAW,KAAK,YAAY,KAAK;AAAA,MAC9D,KAAK,YAAY,KAAK,IAAI,KAAK;AAAA,IAChC,CAAC;AACD,WAAO,QAAQ,SAAS,KAAK,aAAa,UAAU,aAAa,QAAQ,IAAI;AAAA,EAC9E;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,MAAM,mBAAmB;AAAA,IACxB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACD,GAAuE;AACtE,0BAAK,oDAAL;AAEA,UAAM,WAAW,MAAM,KAAK,YAAY,oBAAoB,EAAE,MAAM,SAAS,CAAC;AAE9E,QAAI,SAAS,WAAW,GAAG;AAC1B,YAAM,IAAI;AAAA,QACT,YAAY,QAAQ;AAAA,MACrB;AAAA,IACD;AAEA,UAAM,SAAS,SAAS,CAAC;AAGzB,UAAM,CAAC,eAAe,eAAe,IAAI,KAAK,SAAS;AAAA,MACtD;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACD,CAAC;AAED,QAAI,0BAA0B;AAE9B,eAAW,QAAQ,OAAO,OAAO;AAChC,YAAM,iBAAiB,KAAK,YAAY,MAAM;AAAA,QAC7C,CAAC,UAAM,oCAAsB,EAAE,IAAI,UAAM,oCAAsB,IAAI;AAAA,MACpE;AACA,UAAI,CAAC,eAAgB,OAAM,IAAI,MAAM,uCAAuC,IAAI,GAAG;AAEnF,UAAI,eAAe,eAAgB,2BAA0B;AAE7D,YAAM,eAAe,oBAAoB;AAAA,QACxC,WAAW,eAAe;AAAA,QAC1B,kBAAkB,KAAK;AAAA,QACvB,aAAa,KAAK;AAAA,QAClB;AAAA,QACA;AAAA,QACA,OAAO,MAAM,SAAS;AAAA,QACtB;AAAA,QACA,UAAU,OAAO;AAAA,QACjB;AAAA,QACA;AAAA,QACA,OAAO,KAAK;AAAA,QACZ,UAAU,KAAK;AAAA,QACf,WAAW,aAAa,CAAC;AAAA,QACzB,aAAa,KAAK;AAAA,MACnB,CAAC;AAAA,IACF;AAEA,+CAAe,KAAK,aAAa,UAAU,OAAO,IAAI,eAAe;AAErE,QAAI,wBAAyB,MAAK,MAAM,EAAE,UAAU,MAAM,cAAc,CAAC;AAEzE,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,OAAO,KAAoB;AAC1B,0BAAK,yDAAL;AACA,SAAK,QAAQ,KAAK,YAAY,OAAO,IAAI,OAAO;AAChD,QAAI,CAAC,IAAI,YAAY;AACpB,WAAK,WAAW,KAAK,YAAY,OAAO,IAAI,QAAQ;AACpD;AAAA,IACD;AAEA,WAAO,sBAAK,uDAAL,WAA4B,IAAI;AAAA,EACxC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,WAAW;AACV,0BAAK,oDAAL;AAEA,QAAI,mBAAK,eAAe,MAAK,MAAM;AAGnC,QAAI,CAAC,mBAAK,eAAc;AAEvB,UAAI,mBAAK;AACR,cAAM,IAAI;AAAA,UACT;AAAA,QACD;AACD;AAAA,IACD;AAEA,UAAM,YAAY,KAAK,YAAY,iBAAiB,4BAA4B;AAGhF,QAAI,mBAAK,WAAU;AAClB,WAAK,YAAY,SAAS;AAAA,QACzB,QAAQ,GAAG,SAAS;AAAA,QACpB,WAAW,CAAC,mBAAK,eAAc,KAAK,YAAY,OAAO,KAAK,QAAS,GAAG,mBAAK,SAAS;AAAA,MACvF,CAAC;AAAA,IACF;AAGA,QAAI,mBAAK;AACR,uDAAsB,KAAK,aAAa,mBAAK,eAAc,SAAS;AAGrE,uBAAK,YAAa;AAAA,EACnB;AAAA;AAAA,EAGA,YAAY,KAAgC;AAC3C,0BAAK,yDAAL;AACA,SAAK,WAAW;AAChB,WAAO;AAAA,EACR;AAAA,EAEA,SAAS,OAAkC;AAC1C,0BAAK,yDAAL;AACA,SAAK,QAAQ;AACb,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,WAAW;AACV,0BAAK,yDAAL;AACA,QAAI,CAAC,KAAK,MAAO,OAAM,IAAI,MAAM,mBAAmB;AACpD,WAAO,KAAK;AAAA,EACb;AAAA;AAAA;AAAA;AAAA,EAKA,cAAc;AACb,0BAAK,yDAAL;AACA,QAAI,CAAC,KAAK,SAAU,OAAM,IAAI,MAAM,sBAAsB;AAC1D,WAAO,KAAK;AAAA,EACb;AAuCD;AA1dC;AAEA;AAEA;AAEA;AAEA;AAdM;AAAA;AAAA;AAAA;AA8bN,2BAAsB,SAAC,aAA6B;AACnD,QAAM,CAAC,UAAU,OAAO,IAAI,KAAK,YAAY,SAAS;AAAA,IACrD,QAAQ,GAAG,KAAK,YAAY;AAAA,MAC3B;AAAA,IACD,CAAC;AAAA,IACD,WAAW,CAAC,KAAK,YAAY,OAAO,WAAW,CAAC;AAAA,EACjD,CAAC;AAED,OAAK,WAAW;AAChB,qBAAK,cAAe,KAAK,YAAY,OAAO,WAAW;AACvD,qBAAK,UAAW;AAEhB,SAAO;AACR;AAEA,wBAAmB,SAAC,EAAE,OAAO,SAAS,GAA4C;AACjF,MAAI,aAAa,OAAW,oBAAK,kBAAmB;AACpD,MAAI,UAAU,OAAW,oBAAK,eAAgB;AAC/C;AAEA,wBAAmB,WAAG;AACrB,wBAAK,yDAAL;AAEA,MAAI,CAAC,KAAK,SAAS,CAAC,KAAK;AACxB,UAAM,IAAI;AAAA,MACT;AAAA,IACD;AACF;AAAA;AAGA,6BAAwB,WAAG;AAC1B,MAAI,mBAAK;AACR,UAAM,IAAI,MAAM,mEAAmE;AACrF;",
  "names": []
}
