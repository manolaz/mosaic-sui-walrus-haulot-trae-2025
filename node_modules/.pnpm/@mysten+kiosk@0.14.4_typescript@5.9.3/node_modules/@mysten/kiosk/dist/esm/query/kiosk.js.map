{
  "version": 3,
  "sources": ["../../../src/query/kiosk.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type {\n\tPaginatedObjectsResponse,\n\tPaginationArguments,\n\tSuiClient,\n\tSuiObjectData,\n\tSuiObjectResponse,\n} from '@mysten/sui/client';\nimport { isValidSuiAddress } from '@mysten/sui/utils';\n\nimport type {\n\tFetchKioskOptions,\n\tKioskExtension,\n\tKioskListing,\n\tOwnedKiosks,\n\tPagedKioskData,\n} from '../types/index.js';\nimport { KIOSK_OWNER_CAP } from '../types/index.js';\nimport {\n\tattachListingsAndPrices,\n\tattachLockedItems,\n\tattachObjects,\n\textractKioskData,\n\tgetAllDynamicFields,\n\tgetAllObjects,\n\tgetKioskObject,\n} from '../utils.js';\n\nexport async function fetchKiosk(\n\tclient: SuiClient,\n\tkioskId: string,\n\tpagination: PaginationArguments<string>,\n\toptions: FetchKioskOptions,\n): Promise<PagedKioskData> {\n\t// TODO: Replace the `getAllDynamicFields` with a paginated\n\t// response, once we have better RPC support for\n\t// type filtering & batch fetching.\n\t// This can't work with pagination currently.\n\tconst data = await getAllDynamicFields(client, kioskId, pagination);\n\n\tconst listings: KioskListing[] = [];\n\tconst lockedItemIds: string[] = [];\n\n\t// extracted kiosk data.\n\tconst kioskData = extractKioskData(data, listings, lockedItemIds, kioskId);\n\n\t// split the fetching in two queries as we are most likely passing different options for each kind.\n\t// For items, we usually seek the Display.\n\t// For listings we usually seek the DF value (price) / exclusivity.\n\tconst [kiosk, listingObjects, items] = await Promise.all([\n\t\toptions.withKioskFields ? getKioskObject(client, kioskId) : Promise.resolve(undefined),\n\t\toptions.withListingPrices\n\t\t\t? getAllObjects(client, kioskData.listingIds, {\n\t\t\t\t\tshowContent: true,\n\t\t\t\t})\n\t\t\t: Promise.resolve([]),\n\t\toptions.withObjects\n\t\t\t? getAllObjects(client, kioskData.itemIds, options.objectOptions || { showDisplay: true })\n\t\t\t: Promise.resolve([]),\n\t]);\n\n\tif (options.withKioskFields) kioskData.kiosk = kiosk;\n\t// attach items listings. IF we have `options.withListingPrices === true`, it will also attach the prices.\n\tattachListingsAndPrices(kioskData, listings, listingObjects);\n\t// add `locked` status to items that are locked.\n\tattachLockedItems(kioskData, lockedItemIds);\n\n\t// Attach the objects for the queried items.\n\tattachObjects(\n\t\tkioskData,\n\t\titems.filter((x) => !!x.data).map((x) => x.data!),\n\t);\n\n\treturn {\n\t\tdata: kioskData,\n\t\tnextCursor: null,\n\t\thasNextPage: false,\n\t};\n}\n\n/**\n * A function to fetch all the user's kiosk Caps\n * And a list of the kiosk address ids.\n * Returns a list of `kioskOwnerCapIds` and `kioskIds`.\n * Extra options allow pagination.\n */\n\nconst DEFAULT_PAGE_SIZE = 50;\nconst PERSON_KIOSK_CURSOR = 'personal';\nconst OWNED_KIOSKS_CURSOR = 'owned';\nexport async function getOwnedKiosks(\n\tclient: SuiClient,\n\taddress: string,\n\toptions?: {\n\t\tpagination?: PaginationArguments<string>;\n\t\tpersonalKioskType: string;\n\t},\n): Promise<OwnedKiosks> {\n\t// TODO: this should throw an error, but I am not going to change it right now incase it breaks existing code.\n\tif (!isValidSuiAddress(address)) {\n\t\treturn {\n\t\t\tnextCursor: null,\n\t\t\thasNextPage: false,\n\t\t\tkioskOwnerCaps: [],\n\t\t\tkioskIds: [],\n\t\t};\n\t}\n\n\tconst limit = options?.pagination?.limit ?? DEFAULT_PAGE_SIZE;\n\tconst [cursorType, cursor] = options?.pagination?.cursor?.split(':') ?? [\n\t\tPERSON_KIOSK_CURSOR,\n\t\tnull,\n\t];\n\n\tif (options?.personalKioskType && cursorType === PERSON_KIOSK_CURSOR) {\n\t\tconst personalKioskResponse = formatOwnedKioskResponse(\n\t\t\tawait client.getOwnedObjects({\n\t\t\t\towner: address,\n\t\t\t\tfilter: {\n\t\t\t\t\tStructType: options.personalKioskType,\n\t\t\t\t},\n\t\t\t\toptions: {\n\t\t\t\t\tshowContent: true,\n\t\t\t\t\tshowType: true,\n\t\t\t\t},\n\t\t\t\tcursor,\n\t\t\t\tlimit,\n\t\t\t}),\n\t\t\tPERSON_KIOSK_CURSOR,\n\t\t);\n\n\t\tif (personalKioskResponse.hasNextPage) {\n\t\t\treturn personalKioskResponse;\n\t\t}\n\n\t\tconst remainingLimit = limit - personalKioskResponse.kioskOwnerCaps.length;\n\n\t\t// If we have all personal kiosks, but don't have space for the owned kiosks\n\t\t// we need to start loading owned kiosks for the next page, but don't have a real cursor\n\t\tif (remainingLimit < 1) {\n\t\t\treturn {\n\t\t\t\tnextCursor: `${OWNED_KIOSKS_CURSOR}:`,\n\t\t\t\thasNextPage: true,\n\t\t\t\tkioskOwnerCaps: personalKioskResponse.kioskOwnerCaps,\n\t\t\t\tkioskIds: personalKioskResponse.kioskIds,\n\t\t\t};\n\t\t}\n\n\t\tconst ownedKiosksResponse = formatOwnedKioskResponse(\n\t\t\tawait client.getOwnedObjects({\n\t\t\t\towner: address,\n\t\t\t\tfilter: {\n\t\t\t\t\tStructType: KIOSK_OWNER_CAP,\n\t\t\t\t},\n\t\t\t\toptions: {\n\t\t\t\t\tshowContent: true,\n\t\t\t\t\tshowType: true,\n\t\t\t\t},\n\t\t\t\tlimit: remainingLimit,\n\t\t\t}),\n\t\t\tOWNED_KIOSKS_CURSOR,\n\t\t);\n\n\t\treturn {\n\t\t\tnextCursor: ownedKiosksResponse.nextCursor,\n\t\t\thasNextPage: ownedKiosksResponse.hasNextPage,\n\t\t\tkioskOwnerCaps: [\n\t\t\t\t...personalKioskResponse.kioskOwnerCaps,\n\t\t\t\t...ownedKiosksResponse.kioskOwnerCaps,\n\t\t\t],\n\t\t\tkioskIds: [...personalKioskResponse.kioskIds, ...ownedKiosksResponse.kioskIds],\n\t\t};\n\t}\n\n\treturn formatOwnedKioskResponse(\n\t\tawait client.getOwnedObjects({\n\t\t\towner: address,\n\t\t\tfilter: {\n\t\t\t\tStructType: KIOSK_OWNER_CAP,\n\t\t\t},\n\t\t\toptions: {\n\t\t\t\tshowContent: true,\n\t\t\t\tshowType: true,\n\t\t\t},\n\t\t\t// cursor might be an empty string if the number of personal kiosks was a multiple of the limit.\n\t\t\tcursor: cursor ? cursor : null,\n\t\t\tlimit,\n\t\t}),\n\t\tOWNED_KIOSKS_CURSOR,\n\t);\n}\n\nfunction formatOwnedKioskResponse(\n\tresponse: PaginatedObjectsResponse,\n\tcursorType: string,\n): OwnedKiosks {\n\tconst { data, hasNextPage, nextCursor } = response;\n\t// get kioskIds from the OwnerCaps.\n\tconst kioskIdList = data?.map((x: SuiObjectResponse) => {\n\t\tconst fields =\n\t\t\tx.data?.content?.dataType === 'moveObject'\n\t\t\t\t? (x.data.content.fields as unknown as\n\t\t\t\t\t\t| {\n\t\t\t\t\t\t\t\tcap: { fields: { for: string } };\n\t\t\t\t\t\t\t\tfor?: never;\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t| {\n\t\t\t\t\t\t\t\tcap?: never;\n\t\t\t\t\t\t\t\tfor: string;\n\t\t\t\t\t\t  })\n\t\t\t\t: null;\n\t\treturn fields?.cap ? fields?.cap?.fields?.for : (fields?.for as string);\n\t});\n\n\t// clean up data that might have an error in them.\n\t// only return valid objects.\n\tconst filteredData = data.filter((x) => 'data' in x).map((x) => x.data) as SuiObjectData[];\n\n\treturn {\n\t\tnextCursor: nextCursor ? `${cursorType}:${nextCursor}` : nextCursor,\n\t\thasNextPage,\n\t\tkioskOwnerCaps: filteredData.map((x, idx) => ({\n\t\t\tisPersonal: x.type !== KIOSK_OWNER_CAP,\n\t\t\tdigest: x.digest,\n\t\t\tversion: x.version,\n\t\t\tobjectId: x.objectId,\n\t\t\tkioskId: kioskIdList[idx],\n\t\t})),\n\t\tkioskIds: kioskIdList,\n\t};\n}\n\n// Get a kiosk extension data for a given kioskId and extensionType.\nexport async function fetchKioskExtension(\n\tclient: SuiClient,\n\tkioskId: string,\n\textensionType: string,\n): Promise<KioskExtension | null> {\n\tconst extension = await client.getDynamicFieldObject({\n\t\tparentId: kioskId,\n\t\tname: {\n\t\t\ttype: `0x2::kiosk_extension::ExtensionKey<${extensionType}>`,\n\t\t\tvalue: {\n\t\t\t\tdummy_field: false,\n\t\t\t},\n\t\t},\n\t});\n\n\tif (!extension.data) return null;\n\n\tconst fields = (extension?.data?.content as { fields: { [k: string]: any } })?.fields?.value\n\t\t?.fields;\n\n\treturn {\n\t\tobjectId: extension.data.objectId,\n\t\ttype: extensionType,\n\t\tisEnabled: fields?.is_enabled,\n\t\tpermissions: fields?.permissions,\n\t\tstorageId: fields?.storage?.fields?.id?.id,\n\t\tstorageSize: fields?.storage?.fields?.size,\n\t};\n}\n"],
  "mappings": "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",
  "names": []
}
