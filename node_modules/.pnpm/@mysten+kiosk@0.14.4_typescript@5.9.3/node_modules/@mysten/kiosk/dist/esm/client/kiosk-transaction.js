var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var _pendingShare, _pendingTransfer, _promise, _personalCap, _finalized, _KioskTransaction_instances, borrowFromPersonalCap_fn, setPendingStatuses_fn, validateKioskIsSet_fn, validateFinalizedStatus_fn;
import * as kioskTx from "../tx/kiosk.js";
import { convertToPersonalTx, transferPersonalCapTx } from "../tx/personal-kiosk.js";
import { confirmRequest } from "../tx/transfer-policy.js";
import { getNormalizedRuleType } from "../utils.js";
class KioskTransaction {
  constructor({
    transactionBlock,
    transaction = transactionBlock,
    kioskClient,
    cap
  }) {
    __privateAdd(this, _KioskTransaction_instances);
    // If we're pending `share` of a new kiosk, `finalize()` will share it.
    __privateAdd(this, _pendingShare);
    // If we're pending transferring of the cap, `finalize()` will either error or transfer the cap if it's a new personal.
    __privateAdd(this, _pendingTransfer);
    // The promise that the personalCap will be returned on `finalize()`.
    __privateAdd(this, _promise);
    // The personal kiosk argument.
    __privateAdd(this, _personalCap);
    // A flag that checks whether kiosk TX is finalized.
    __privateAdd(this, _finalized, false);
    this.transaction = transaction;
    this.kioskClient = kioskClient;
    if (cap) this.setCap(cap);
  }
  /**
   * Creates a kiosk and saves `kiosk` and `kioskOwnerCap` in state.
   * Helpful if we want to chain some actions before sharing + transferring the cap to the specified address.
   * @param borrow If true, the `kioskOwnerCap` is borrowed from the `PersonalKioskCap` to be used in next transactions.
   */
  create() {
    __privateMethod(this, _KioskTransaction_instances, validateFinalizedStatus_fn).call(this);
    __privateMethod(this, _KioskTransaction_instances, setPendingStatuses_fn).call(this, {
      share: true,
      transfer: true
    });
    const [kiosk, cap] = kioskTx.createKiosk(this.transaction);
    this.kiosk = kiosk;
    this.kioskCap = cap;
    return this;
  }
  /**
   * Creates a personal kiosk & shares it.
   * The `PersonalKioskCap` is transferred to the signer.
   * @param borrow If true, the `kioskOwnerCap` is borrowed from the `PersonalKioskCap` to be used in next transactions.
   */
  createPersonal(borrow) {
    __privateSet(this, _pendingShare, true);
    return this.create().convertToPersonal(borrow);
  }
  /**
   * Converts a kiosk to a Personal (Soulbound) Kiosk.
   * Requires initialization by either calling `ktxb.create()` or `ktxb.setCap()`.
   */
  convertToPersonal(borrow) {
    __privateMethod(this, _KioskTransaction_instances, validateKioskIsSet_fn).call(this);
    const cap = convertToPersonalTx(
      this.transaction,
      this.kiosk,
      this.kioskCap,
      this.kioskClient.getRulePackageId("personalKioskRulePackageId")
    );
    if (borrow) __privateMethod(this, _KioskTransaction_instances, borrowFromPersonalCap_fn).call(this, cap);
    else __privateSet(this, _personalCap, cap);
    __privateMethod(this, _KioskTransaction_instances, setPendingStatuses_fn).call(this, { transfer: true });
    return this;
  }
  /**
   * Single function way to create a kiosk, share it and transfer the cap to the specified address.
   */
  createAndShare(address) {
    __privateMethod(this, _KioskTransaction_instances, validateFinalizedStatus_fn).call(this);
    const cap = kioskTx.createKioskAndShare(this.transaction);
    this.transaction.transferObjects([cap], this.transaction.pure.address(address));
    return this;
  }
  /**
   * Shares the kiosk.
   */
  share() {
    __privateMethod(this, _KioskTransaction_instances, validateKioskIsSet_fn).call(this);
    __privateMethod(this, _KioskTransaction_instances, setPendingStatuses_fn).call(this, { share: false });
    kioskTx.shareKiosk(this.transaction, this.kiosk);
    return this;
  }
  /**
   * Should be called only after `create` is called.
   * It shares the kiosk & transfers the cap to the specified address.
   */
  shareAndTransferCap(address) {
    if (__privateGet(this, _personalCap))
      throw new Error("You can only call `shareAndTransferCap` on a non-personal kiosk.");
    __privateMethod(this, _KioskTransaction_instances, setPendingStatuses_fn).call(this, { transfer: false });
    this.share();
    this.transaction.transferObjects([this.kioskCap], this.transaction.pure.address(address));
    return this;
  }
  /**
   * A function to borrow an item from a kiosk & execute any function with it.
   * Example: You could borrow a Fren out of a kiosk, attach an accessory (or mix), and return it.
   */
  borrowTx({ itemType, itemId }, callback) {
    __privateMethod(this, _KioskTransaction_instances, validateKioskIsSet_fn).call(this);
    const [itemObj, promise] = kioskTx.borrowValue(
      this.transaction,
      itemType,
      this.kiosk,
      this.kioskCap,
      itemId
    );
    callback(itemObj);
    return this.return({ itemType, item: itemObj, promise });
  }
  /**
   * Borrows an item from the kiosk.
   * This will fail if the item is listed for sale.
   *
   * Requires calling `return`.
   */
  borrow({ itemType, itemId }) {
    __privateMethod(this, _KioskTransaction_instances, validateKioskIsSet_fn).call(this);
    const [itemObj, promise] = kioskTx.borrowValue(
      this.transaction,
      itemType,
      this.kiosk,
      this.kioskCap,
      itemId
    );
    return [itemObj, promise];
  }
  /**
   * Returns the item back to the kiosk.
   * Accepts the parameters returned from the `borrow` function.
   */
  return({ itemType, item, promise }) {
    __privateMethod(this, _KioskTransaction_instances, validateKioskIsSet_fn).call(this);
    kioskTx.returnValue(this.transaction, itemType, this.kiosk, item, promise);
    return this;
  }
  /**
   * A function to withdraw from kiosk
   * @param address Where to trasnfer the coin.
   * @param amount The amount we aim to withdraw.
   */
  withdraw(address, amount) {
    __privateMethod(this, _KioskTransaction_instances, validateKioskIsSet_fn).call(this);
    const coin = kioskTx.withdrawFromKiosk(this.transaction, this.kiosk, this.kioskCap, amount);
    this.transaction.transferObjects([coin], this.transaction.pure.address(address));
    return this;
  }
  /**
   * A function to place an item in the kiosk.
   * @param itemType The type `T` of the item
   * @param item The ID or Transaction Argument of the item
   */
  place({ itemType, item }) {
    __privateMethod(this, _KioskTransaction_instances, validateKioskIsSet_fn).call(this);
    kioskTx.place(this.transaction, itemType, this.kiosk, this.kioskCap, item);
    return this;
  }
  /**
   * A function to place an item in the kiosk and list it for sale in one transaction.
   * @param itemType The type `T` of the item
   * @param item The ID or Transaction Argument of the item
   * @param price The price in MIST
   */
  placeAndList({ itemType, item, price }) {
    __privateMethod(this, _KioskTransaction_instances, validateKioskIsSet_fn).call(this);
    kioskTx.placeAndList(this.transaction, itemType, this.kiosk, this.kioskCap, item, price);
    return this;
  }
  /**
   * A function to list an item in the kiosk.
   * @param itemType The type `T` of the item
   * @param itemId The ID of the item
   * @param price The price in MIST
   */
  list({ itemType, itemId, price }) {
    __privateMethod(this, _KioskTransaction_instances, validateKioskIsSet_fn).call(this);
    kioskTx.list(this.transaction, itemType, this.kiosk, this.kioskCap, itemId, price);
    return this;
  }
  /**
   * A function to delist an item from the kiosk.
   * @param itemType The type `T` of the item
   * @param itemId The ID of the item
   */
  delist({ itemType, itemId }) {
    __privateMethod(this, _KioskTransaction_instances, validateKioskIsSet_fn).call(this);
    kioskTx.delist(this.transaction, itemType, this.kiosk, this.kioskCap, itemId);
    return this;
  }
  /**
  	 * A function to take an item from the kiosk. The transaction won't succeed if the item is listed or locked.
  
  	 * @param itemType The type `T` of the item
  	 * @param itemId The ID of the item
  	 */
  take({ itemType, itemId }) {
    __privateMethod(this, _KioskTransaction_instances, validateKioskIsSet_fn).call(this);
    return kioskTx.take(this.transaction, itemType, this.kiosk, this.kioskCap, itemId);
  }
  /**
   * Transfer a non-locked/non-listed item to an address.
   *
   * @param itemType The type `T` of the item
   * @param itemId The ID of the item
   * @param address The destination address
   */
  transfer({ itemType, itemId, address }) {
    __privateMethod(this, _KioskTransaction_instances, validateKioskIsSet_fn).call(this);
    const item = this.take({ itemType, itemId });
    this.transaction.transferObjects([item], this.transaction.pure.address(address));
    return this;
  }
  /**
  	 * A function to take lock an item in the kiosk.
  
  	 * @param itemType The type `T` of the item
  	 * @param item The ID or Transaction Argument of the item
  	 * @param itemId The ID of the item - Deprecated: Use `item` instead.
  	 * @param policy The Policy ID or Transaction Argument for item T
  	 */
  lock({
    itemType,
    item,
    itemId,
    policy
  }) {
    __privateMethod(this, _KioskTransaction_instances, validateKioskIsSet_fn).call(this);
    kioskTx.lock(this.transaction, itemType, this.kiosk, this.kioskCap, policy, itemId ?? item);
    return this;
  }
  /**
   * Purchase an item from a seller's kiosk.
   * Returns [item, transferRequest]
   * Can be called like: `const [item, transferRequest] = kioskTx.purchase({...})`
   * @param itemType The type `T` of the item
   * @param itemId The ID of the item
   * @param price The price in MIST
   * @param sellerKiosk The kiosk which is selling the item. Can be an id or an object argument.
   */
  purchase({
    itemType,
    itemId,
    price,
    sellerKiosk
  }) {
    const coin = this.transaction.splitCoins(this.transaction.gas, [
      this.transaction.pure.u64(price)
    ]);
    return kioskTx.purchase(this.transaction, itemType, sellerKiosk, itemId, coin);
  }
  /**
   * A function to purchase and resolve a transfer policy.
   * If the transfer policy has the `lock` rule, the item is locked in the kiosk.
   * Otherwise, the item is placed in the kiosk.
   * @param itemType The type of the item
   * @param itemId The id of the item
   * @param price The price of the specified item
   * @param sellerKiosk The kiosk which is selling the item. Can be an id or an object argument.
   * @param extraArgs Used to pass arguments for custom rule resolvers.
   */
  async purchaseAndResolve({
    itemType,
    itemId,
    price,
    sellerKiosk,
    extraArgs
  }) {
    __privateMethod(this, _KioskTransaction_instances, validateKioskIsSet_fn).call(this);
    const policies = await this.kioskClient.getTransferPolicies({ type: itemType });
    if (policies.length === 0) {
      throw new Error(
        `The type ${itemType} doesn't have a Transfer Policy so it can't be traded through kiosk.`
      );
    }
    const policy = policies[0];
    const [purchasedItem, transferRequest] = this.purchase({
      itemType,
      itemId,
      price,
      sellerKiosk
    });
    let canTransferOutsideKiosk = true;
    for (const rule of policy.rules) {
      const ruleDefinition = this.kioskClient.rules.find(
        (x) => getNormalizedRuleType(x.rule) === getNormalizedRuleType(rule)
      );
      if (!ruleDefinition) throw new Error(`No resolver for the following rule: ${rule}.`);
      if (ruleDefinition.hasLockingRule) canTransferOutsideKiosk = false;
      await ruleDefinition.resolveRuleFunction({
        packageId: ruleDefinition.packageId,
        transactionBlock: this.transaction,
        transaction: this.transaction,
        itemType,
        itemId,
        price: price.toString(),
        sellerKiosk,
        policyId: policy.id,
        transferRequest,
        purchasedItem,
        kiosk: this.kiosk,
        kioskCap: this.kioskCap,
        extraArgs: extraArgs || {},
        kioskClient: this.kioskClient
      });
    }
    confirmRequest(this.transaction, itemType, policy.id, transferRequest);
    if (canTransferOutsideKiosk) this.place({ itemType, item: purchasedItem });
    return this;
  }
  /**
   * A function to setup the client using an existing `ownerCap`,
   * as return from the `kioskClient.getOwnedKiosks` function.
   * @param cap `KioskOwnerCap` object as returned from `getOwnedKiosks` SDK call.
   */
  setCap(cap) {
    __privateMethod(this, _KioskTransaction_instances, validateFinalizedStatus_fn).call(this);
    this.kiosk = this.transaction.object(cap.kioskId);
    if (!cap.isPersonal) {
      this.kioskCap = this.transaction.object(cap.objectId);
      return;
    }
    return __privateMethod(this, _KioskTransaction_instances, borrowFromPersonalCap_fn).call(this, cap.objectId);
  }
  /**
   *	A function that ends up the kiosk building tx & returns the `kioskOwnerCap` back to the
   *  `PersonalKioskCap`, in case we are operating on a personal kiosk.
   * 	It will also share the `kiosk` if it's not shared, and finalize the transfer of the personal cap if it's pending.
   */
  finalize() {
    __privateMethod(this, _KioskTransaction_instances, validateKioskIsSet_fn).call(this);
    if (__privateGet(this, _pendingShare)) this.share();
    if (!__privateGet(this, _personalCap)) {
      if (__privateGet(this, _pendingTransfer))
        throw new Error(
          "You need to transfer the `kioskOwnerCap` by calling `shareAndTransferCap()` before wrap"
        );
      return;
    }
    const packageId = this.kioskClient.getRulePackageId("personalKioskRulePackageId");
    if (__privateGet(this, _promise)) {
      this.transaction.moveCall({
        target: `${packageId}::personal_kiosk::return_val`,
        arguments: [__privateGet(this, _personalCap), this.transaction.object(this.kioskCap), __privateGet(this, _promise)]
      });
    }
    if (__privateGet(this, _pendingTransfer))
      transferPersonalCapTx(this.transaction, __privateGet(this, _personalCap), packageId);
    __privateSet(this, _finalized, true);
  }
  // Some setters in case we want custom behavior.
  setKioskCap(cap) {
    __privateMethod(this, _KioskTransaction_instances, validateFinalizedStatus_fn).call(this);
    this.kioskCap = cap;
    return this;
  }
  setKiosk(kiosk) {
    __privateMethod(this, _KioskTransaction_instances, validateFinalizedStatus_fn).call(this);
    this.kiosk = kiosk;
    return this;
  }
  // Some getters
  /*
   * Returns the active transaction's kiosk, or undefined if `setCap` or `create()` hasn't been called yet.
   */
  getKiosk() {
    __privateMethod(this, _KioskTransaction_instances, validateFinalizedStatus_fn).call(this);
    if (!this.kiosk) throw new Error("Kiosk is not set.");
    return this.kiosk;
  }
  /*
   * Returns the active transaction's kioskOwnerCap, or undefined if `setCap` or `create()` hasn't been called yet.
   */
  getKioskCap() {
    __privateMethod(this, _KioskTransaction_instances, validateFinalizedStatus_fn).call(this);
    if (!this.kioskCap) throw new Error("Kiosk cap is not set");
    return this.kioskCap;
  }
}
_pendingShare = new WeakMap();
_pendingTransfer = new WeakMap();
_promise = new WeakMap();
_personalCap = new WeakMap();
_finalized = new WeakMap();
_KioskTransaction_instances = new WeakSet();
/**
 * A function to borrow from `personalCap`.
 */
borrowFromPersonalCap_fn = function(personalCap) {
  const [kioskCap, promise] = this.transaction.moveCall({
    target: `${this.kioskClient.getRulePackageId(
      "personalKioskRulePackageId"
    )}::personal_kiosk::borrow_val`,
    arguments: [this.transaction.object(personalCap)]
  });
  this.kioskCap = kioskCap;
  __privateSet(this, _personalCap, this.transaction.object(personalCap));
  __privateSet(this, _promise, promise);
  return this;
};
setPendingStatuses_fn = function({ share, transfer }) {
  if (transfer !== void 0) __privateSet(this, _pendingTransfer, transfer);
  if (share !== void 0) __privateSet(this, _pendingShare, share);
};
validateKioskIsSet_fn = function() {
  __privateMethod(this, _KioskTransaction_instances, validateFinalizedStatus_fn).call(this);
  if (!this.kiosk || !this.kioskCap)
    throw new Error(
      "You need to initialize the client by either supplying an existing owner cap or by creating a new by calling `.create()`"
    );
};
// Validates that `finalize`
validateFinalizedStatus_fn = function() {
  if (__privateGet(this, _finalized))
    throw new Error("You can't add more transactions to a finalized kiosk transaction.");
};
export {
  KioskTransaction
};
//# sourceMappingURL=kiosk-transaction.js.map
