"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var uri_exports = {};
__export(uri_exports, {
  createPaymentTransactionUri: () => createPaymentTransactionUri,
  parsePaymentTransactionUri: () => parsePaymentTransactionUri
});
module.exports = __toCommonJS(uri_exports);
var import_utils = require("@mysten/sui/utils");
var import_error = require("./error.js");
var import_constants = require("./constants.js");
const isValidNonce = (nonce) => {
  return nonce.length <= 36;
};
const isValidAmount = (amount) => {
  return amount > 0n;
};
const isValidCoinType = (coinType) => {
  return (0, import_utils.isValidNamedType)(coinType);
};
const createPaymentTransactionUri = (params) => {
  const { receiverAddress, amount, coinType, nonce, registryId, registryName } = params;
  const uri = new URL(import_constants.SUI_PAYMENT_KIT_PROTOCOL);
  if ((0, import_utils.isValidSuiAddress)(receiverAddress)) {
    uri.searchParams.append("receiver", receiverAddress);
  } else {
    throw new import_error.PaymentKitUriError("Invalid Sui address");
  }
  if (isValidAmount(amount)) {
    uri.searchParams.append("amount", amount.toString());
  } else {
    throw new import_error.PaymentKitUriError("Amount must be a positive numeric string");
  }
  if (isValidCoinType(coinType)) {
    uri.searchParams.append("coinType", coinType);
  } else {
    throw new import_error.PaymentKitUriError("Invalid Coin Type");
  }
  if (isValidNonce(nonce)) {
    uri.searchParams.append("nonce", nonce);
  } else {
    throw new import_error.PaymentKitUriError("Nonce length exceeds maximum of 36 characters");
  }
  if (registryId) {
    if ((0, import_utils.isValidSuiObjectId)(registryId)) {
      uri.searchParams.append("registry", registryId);
    } else {
      throw new import_error.PaymentKitUriError("Invalid Sui Object Id for Registry Id");
    }
  }
  if (registryName) {
    uri.searchParams.append("registry", registryName);
  }
  if (params.label) {
    uri.searchParams.append("label", params.label);
  }
  if (params.message) {
    uri.searchParams.append("message", params.message);
  }
  if (params.iconUrl) {
    uri.searchParams.append("iconUrl", params.iconUrl);
  }
  return uri.toString();
};
const parsePaymentTransactionUri = (uri) => {
  if (!uri.startsWith(import_constants.SUI_PAYMENT_KIT_PROTOCOL + "?")) {
    throw new import_error.PaymentKitUriError("Invalid URI: Must start with sui:pay?");
  }
  const url = new URL(uri);
  const params = url.searchParams;
  const receiver = params.get("receiver");
  const amount = params.get("amount");
  const coinType = params.get("coinType");
  const nonce = params.get("nonce");
  if (!receiver || !amount || !coinType || !nonce) {
    throw new import_error.PaymentKitUriError("Invalid URI: Missing required parameters");
  }
  if (!(0, import_utils.isValidSuiAddress)(receiver)) {
    throw new import_error.PaymentKitUriError("Invalid URI: Receiver address is not valid");
  }
  if (!isValidCoinType(coinType)) {
    throw new import_error.PaymentKitUriError("Invalid URI: Coin Type is not valid");
  }
  if (!isValidNonce(nonce)) {
    throw new import_error.PaymentKitUriError("Invalid URI: Nonce length exceeds maximum of 36 characters");
  }
  const bigIntAmount = BigInt(amount);
  if (!isValidAmount(bigIntAmount)) {
    throw new import_error.PaymentKitUriError("Invalid URI: Amount must be a positive number");
  }
  const registry = params.get("registry") ?? void 0;
  let registryId;
  let registryName;
  if (registry) {
    if ((0, import_utils.isValidSuiObjectId)(registry)) {
      registryId = registry;
    } else {
      registryName = registry;
    }
  }
  const baseParams = {
    receiverAddress: receiver,
    amount: bigIntAmount,
    coinType,
    nonce,
    label: params.get("label") ?? void 0,
    message: params.get("message") ?? void 0,
    iconUrl: params.get("icon") ?? void 0
  };
  if (registryId) {
    return { ...baseParams, registryId };
  }
  return { ...baseParams, registryName };
};
//# sourceMappingURL=uri.js.map
