{
  "version": 3,
  "sources": ["../../../../../src/storage/adapters/walrus/walrus.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport type { ClientWithExtensions } from '@mysten/sui/experimental';\nimport type { StorageAdapter, StorageConfig, StorageOptions } from '../storage.js';\nimport type { WalrusClient } from '@mysten/walrus';\nimport type { WalrusResponse } from './types.js';\n\nexport class WalrusStorageAdapter implements StorageAdapter {\n\tconstructor(\n\t\t// Client parameter kept for future implementation - currently unused\n\t\t// @ts-expect-error TS6138 - intentionally unused parameter for future implementation\n\t\tprivate readonly _client: ClientWithExtensions<{ walrus?: WalrusClient }>,\n\t\tprivate readonly config: StorageConfig,\n\t) {}\n\n\t/**\n\t * Upload data to Walrus storage\n\t * @param data - Array of data to upload\n\t * @param _options - Storage options (currently unused)\n\t * @returns Upload result with blob IDs\n\t */\n\tasync upload(data: Uint8Array[], _options: StorageOptions): Promise<{ ids: string[] }> {\n\t\treturn await this.#uploadQuilts(data); // todo: option handling for blobs vs quilts\n\t}\n\n\t/**\n\t * Download data from Walrus storage\n\t * @param ids - Array of blob IDs to download\n\t * @returns Array of downloaded data\n\t */\n\tasync download(ids: string[]): Promise<Uint8Array[]> {\n\t\tif (ids.length === 0) {\n\t\t\treturn [];\n\t\t}\n\t\treturn await this.#downloadQuilts(ids);\n\t}\n\n\t/**\n\t * Upload data as quilts to Walrus\n\t * @param data - Array of data to upload\n\t * @returns Upload result with quilt patch IDs\n\t */\n\tasync #uploadQuilts(data: Uint8Array[]): Promise<{ ids: string[] }> {\n\t\tconst formData = new FormData();\n\n\t\tfor (let i = 0; i < data.length; i++) {\n\t\t\tconst identifier = `attachment${i}`;\n\t\t\tconst blob = new Blob([new Uint8Array(data[i])]);\n\t\t\tformData.append(identifier, blob);\n\t\t}\n\n\t\tconst response = await fetch(\n\t\t\t`${this.config.publisher}/v1/quilts?epochs=${this.config.epochs}`,\n\t\t\t{\n\t\t\t\tmethod: 'PUT',\n\t\t\t\tbody: formData,\n\t\t\t},\n\t\t);\n\t\tif (!response.ok) {\n\t\t\t// Read the error response body to get the actual error message\n\t\t\tconst errorText = await response.text();\n\t\t\tconsole.error('Error response body:', errorText);\n\t\t\tthrow new Error(\n\t\t\t\t`Walrus upload failed: ${response.status} ${response.statusText} - ${errorText}`,\n\t\t\t);\n\t\t}\n\n\t\tconst result = await response.json();\n\t\t// const blobId = this.#extractBlobId(result as WalrusResponse);\n\t\t// TODO: figure out the Types, so we avoid the use of any\n\t\t//  // @ts-ignore\n\t\t// console.log((await this.client.walrus.getBlob({blobId})));\n\t\treturn { ids: this.#extractQuiltsPatchIds(result as WalrusResponse) };\n\t}\n\n\t/**\n\t * Download data from Walrus quilts\n\t * @param patchIds - Array of quilt patch IDs to download\n\t * @returns Array of downloaded data\n\t */\n\tasync #downloadQuilts(patchIds: string[]): Promise<Uint8Array[]> {\n\t\t/* OpenApi\n  /v1/blobs/by-quilt-id/{quilt_id}/{identifier}:\n    get:\n      tags:\n      - routes\n      summary: Get blob from quilt by ID and identifier\n      description: Retrieve a specific blob from a quilt using the quilt ID and its identifier. Returns the raw blob bytes, the identifier and other attributes are returned as headers. If the quilt ID or identifier is not found, the response is 404.\n      operationId: get_blob_by_quilt_id_and_identifier\n      parameters:\n      - name: quilt_id\n        in: path\n        description: The quilt ID encoded as URL-safe base64\n        required: true\n        schema:\n          $ref: '#/components/schemas/BlobId'\n        example: rkcHpHQrornOymttgvSq3zvcmQEsMqzmeUM1HSY4ShU\n      - name: identifier\n        in: path\n        description: The identifier of the blob within the quilt\n        required: true\n        schema:\n          type: string\n        example: my-file.txt\n      responses:\n        '200':\n          description: The blob was retrieved successfully. Returns the raw blob bytes, the identifier and other attributes are returned as headers.\n          content:\n            application/octet-stream:\n              schema:\n                type: array\n                items:\n                  type: integer\n                  format: int32\n                  minimum: 0\n        '404':\n          description: May be returned when (1) The requested blob has not yet been stored on Walrus. (2) The requested quilt patch does not exist on Walrus.\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Status'\n        '451':\n          description: The blob cannot be returned as has been blocked.\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Status'\n        '500':\n          description: An internal server error has occurred. Please report this error.\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Status'\n\t\t*/\n\n\t\tconst response = await Promise.all(\n\t\t\tpatchIds.map(\n\t\t\t\tasync (id) => await fetch(`${this.config.aggregator}/v1/blobs/by-quilt-patch-id/${id}`),\n\t\t\t),\n\t\t);\n\t\tconst data = await Promise.all(response.map(async (response) => await response.arrayBuffer()));\n\t\treturn data.map((data) => new Uint8Array(data));\n\t}\n\n\t/**\n\t * Extract blob ID from Walrus response\n\t * @param response - Walrus API response\n\t * @returns Extracted blob ID\n\t */\n\t// @ts-expect-error Method is currently unused but kept for future implementation\n\t#extractBlobId(response: WalrusResponse): string {\n\t\t// direct blob uploads\n\t\tif (response.newlyCreated?.blobObject?.blobId) {\n\t\t\treturn response.newlyCreated.blobObject.blobId;\n\t\t}\n\t\tif (response.alreadyCertified?.blobId) {\n\t\t\treturn response.alreadyCertified.blobId;\n\t\t}\n\n\t\t// quilt uploads\n\t\tif (response.blobStoreResult?.newlyCreated?.blobObject?.blobId) {\n\t\t\treturn response.blobStoreResult.newlyCreated.blobObject.blobId;\n\t\t}\n\n\t\tthrow new Error('Unable to extract blob ID from response');\n\t}\n\n\t/**\n\t * Extract quilt patch IDs from Walrus response\n\t * @param response - Walrus API response\n\t * @returns Array of quilt patch IDs\n\t */\n\t#extractQuiltsPatchIds(response: WalrusResponse): string[] {\n\t\tif (response.storedQuiltBlobs) {\n\t\t\treturn response.storedQuiltBlobs.map((quilt) => quilt.quiltPatchId);\n\t\t}\n\n\t\tthrow new Error('Unable to extract quilt patch IDs from response');\n\t}\n}\n"],
  "mappings": ";;;;;;AAAA;AAOO,MAAM,qBAA+C;AAAA,EAC3D,YAGkB,SACA,QAChB;AAFgB;AACA;AALZ;AAAA,EAMH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQH,MAAM,OAAO,MAAoB,UAAsD;AACtF,WAAO,MAAM,sBAAK,kDAAL,WAAmB;AAAA,EACjC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,SAAS,KAAsC;AACpD,QAAI,IAAI,WAAW,GAAG;AACrB,aAAO,CAAC;AAAA,IACT;AACA,WAAO,MAAM,sBAAK,oDAAL,WAAqB;AAAA,EACnC;AAgJD;AA5KO;AAmCA,kBAAa,eAAC,MAAgD;AACnE,QAAM,WAAW,IAAI,SAAS;AAE9B,WAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACrC,UAAM,aAAa,aAAa,CAAC;AACjC,UAAM,OAAO,IAAI,KAAK,CAAC,IAAI,WAAW,KAAK,CAAC,CAAC,CAAC,CAAC;AAC/C,aAAS,OAAO,YAAY,IAAI;AAAA,EACjC;AAEA,QAAM,WAAW,MAAM;AAAA,IACtB,GAAG,KAAK,OAAO,SAAS,qBAAqB,KAAK,OAAO,MAAM;AAAA,IAC/D;AAAA,MACC,QAAQ;AAAA,MACR,MAAM;AAAA,IACP;AAAA,EACD;AACA,MAAI,CAAC,SAAS,IAAI;AAEjB,UAAM,YAAY,MAAM,SAAS,KAAK;AACtC,YAAQ,MAAM,wBAAwB,SAAS;AAC/C,UAAM,IAAI;AAAA,MACT,yBAAyB,SAAS,MAAM,IAAI,SAAS,UAAU,MAAM,SAAS;AAAA,IAC/E;AAAA,EACD;AAEA,QAAM,SAAS,MAAM,SAAS,KAAK;AAKnC,SAAO,EAAE,KAAK,sBAAK,2DAAL,WAA4B,QAA0B;AACrE;AAOM,oBAAe,eAAC,UAA2C;AAuDhE,QAAM,WAAW,MAAM,QAAQ;AAAA,IAC9B,SAAS;AAAA,MACR,OAAO,OAAO,MAAM,MAAM,GAAG,KAAK,OAAO,UAAU,+BAA+B,EAAE,EAAE;AAAA,IACvF;AAAA,EACD;AACA,QAAM,OAAO,MAAM,QAAQ,IAAI,SAAS,IAAI,OAAOA,cAAa,MAAMA,UAAS,YAAY,CAAC,CAAC;AAC7F,SAAO,KAAK,IAAI,CAACC,UAAS,IAAI,WAAWA,KAAI,CAAC;AAC/C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA,mBAAc,SAAC,UAAkC;AAEhD,MAAI,SAAS,cAAc,YAAY,QAAQ;AAC9C,WAAO,SAAS,aAAa,WAAW;AAAA,EACzC;AACA,MAAI,SAAS,kBAAkB,QAAQ;AACtC,WAAO,SAAS,iBAAiB;AAAA,EAClC;AAGA,MAAI,SAAS,iBAAiB,cAAc,YAAY,QAAQ;AAC/D,WAAO,SAAS,gBAAgB,aAAa,WAAW;AAAA,EACzD;AAEA,QAAM,IAAI,MAAM,yCAAyC;AAC1D;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA,2BAAsB,SAAC,UAAoC;AAC1D,MAAI,SAAS,kBAAkB;AAC9B,WAAO,SAAS,iBAAiB,IAAI,CAAC,UAAU,MAAM,YAAY;AAAA,EACnE;AAEA,QAAM,IAAI,MAAM,iDAAiD;AAClE;",
  "names": ["response", "data"]
}
