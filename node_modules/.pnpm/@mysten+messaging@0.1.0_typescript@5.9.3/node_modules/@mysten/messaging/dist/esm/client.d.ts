import { Transaction } from '@mysten/sui/transactions';
import type { Signer } from '@mysten/sui/cryptography';
import type { SessionKey } from '@mysten/seal';
import type { AddedMemberCap, AddMembersOptions, AddMembersTransactionOptions, ChannelMembershipsRequest, ChannelMembershipsResponse, ChannelMembersResponse, CreateChannelFlow, CreateChannelFlowOpts, DecryptedChannelObject, DecryptedChannelObjectsByAddressResponse, DecryptedMessagesResponse, ExecuteAddMembersTransactionOptions, GetChannelMessagesRequest, GetChannelObjectsByChannelIdsRequest, GetLatestMessagesRequest, MessagingClientExtensionOptions, MessagingClientOptions, MessagingCompatibleClient } from './types.js';
import type { EncryptedSymmetricKey } from './encryption/types.js';
export declare class SuiStackMessagingClient {
    #private;
    options: MessagingClientOptions;
    private constructor();
    static experimental_asClientExtension(options: MessagingClientExtensionOptions): {
        name: "messaging";
        register: (client: MessagingCompatibleClient) => SuiStackMessagingClient;
    };
    /**
     * Get channel memberships for a user
     * @param request - Pagination and filter options
     * @returns Channel memberships with pagination info
     */
    getChannelMemberships(request: ChannelMembershipsRequest): Promise<ChannelMembershipsResponse>;
    /**
     * Get channel objects for a user (returns decrypted data)
     * @param request - Pagination and filter options
     * @returns Decrypted channel objects with pagination info
     */
    getChannelObjectsByAddress(request: ChannelMembershipsRequest): Promise<DecryptedChannelObjectsByAddressResponse>;
    /**
     * Get channel objects by channel IDs (returns decrypted data)
     * @param request - Request with channel IDs and user address, and optionally memberCapIds
     * @returns Decrypted channel objects
     */
    getChannelObjectsByChannelIds(request: GetChannelObjectsByChannelIdsRequest): Promise<DecryptedChannelObject[]>;
    /**
     * Get all members of a channel
     * @param channelId - The channel ID
     * @returns Channel members with addresses and member cap IDs
     */
    getChannelMembers(channelId: string): Promise<ChannelMembersResponse>;
    /**
     * Get messages from a channel with pagination (returns decrypted messages)
     * @param request - Request parameters including channelId, userAddress, cursor, limit, and direction
     * @returns Decrypted messages with pagination info
     */
    getChannelMessages({ channelId, userAddress, cursor, limit, direction, }: GetChannelMessagesRequest): Promise<DecryptedMessagesResponse>;
    /**
     * Get new messages since last polling state (returns decrypted messages)
     * @param request - Request with channelId, userAddress, pollingState, and limit
     * @returns New decrypted messages since last poll
     */
    getLatestMessages({ channelId, userAddress, pollingState, limit, }: GetLatestMessagesRequest): Promise<DecryptedMessagesResponse>;
    /**
     * Create a channel creation flow
     *
     * @usage
     * ```
     * const flow = client.createChannelFlow();
     *
     * // Step-by-step execution
     * // 1. build
     * const tx = flow.build();
     * // 2. getGeneratedCaps
     * const { creatorCap, creatorMemberCap, additionalMemberCaps } = await flow.getGeneratedCaps({ digest });
     * // 3. generateAndAttachEncryptionKey
     * const { transaction, creatorCap, encryptedKeyBytes } = await flow.generateAndAttachEncryptionKey({ creatorCap, creatorMemberCap });
     * // 4. getGeneratedEncryptionKey
     * const { channelId, encryptedKeyBytes } = await flow.getGeneratedEncryptionKey({ creatorCap, encryptedKeyBytes });
     * ```
     *
     * @param opts - Options including creator address and initial members
     * @returns Channel creation flow with step-by-step methods
     */
    createChannelFlow({ creatorAddress, initialMemberAddresses, }: CreateChannelFlowOpts): CreateChannelFlow;
    /**
     * Create a send message transaction builder
     * @param channelId - The channel ID
     * @param memberCapId - The member cap ID
     * @param sender - The sender address
     * @param message - The message text
     * @param encryptedKey - The encrypted symmetric key
     * @param attachments - Optional file attachments
     * @returns Transaction builder function
     */
    sendMessage(channelId: string, memberCapId: string, sender: string, message: string, encryptedKey: EncryptedSymmetricKey, attachments?: File[]): Promise<(tx: Transaction) => Promise<void>>;
    /**
     * Execute a send message transaction
     * @param params - Transaction parameters including signer, channelId, memberCapId, message, and encryptedKey
     * @returns Transaction digest and message ID
     */
    executeSendMessageTransaction({ signer, channelId, memberCapId, message, attachments, encryptedKey, }: {
        channelId: string;
        memberCapId: string;
        message: string;
        encryptedKey: EncryptedSymmetricKey;
        attachments?: File[];
    } & {
        signer: Signer;
    }): Promise<{
        digest: string;
        messageId: string;
    }>;
    /**
     * Add members to a channel
     *
     * @example
     * ```ts
     * tx.add(client.addMembers({
     *   channelId,
     *   memberCapId,
     *   newMemberAddresses: ['0xabc...', '0xdef...'],
     *   creatorCapId
     * }));
     * ```
     */
    addMembers({ channelId, memberCapId, newMemberAddresses, creatorCapId }: AddMembersOptions): (tx: Transaction) => Promise<void>;
    /**
     * Create a transaction that adds members to a channel
     *
     * @example
     * ```ts
     * const tx = client.addMembersTransaction({
     *   channelId,
     *   memberCapId,
     *   newMemberAddresses: ['0xabc...', '0xdef...'],
     *   creatorCapId
     * });
     * ```
     */
    addMembersTransaction({ transaction, ...options }: AddMembersTransactionOptions): Transaction;
    /**
     * Execute a transaction that adds members to a channel
     *
     * @example
     * ```ts
     * const { digest, addedMembers } = await client.executeAddMembersTransaction({
     *   channelId,
     *   memberCapId,
     *   newMemberAddresses: ['0xabc...', '0xdef...'],
     *   creatorCapId,
     *   signer
     * });
     * // addedMembers contains { memberCap, ownerAddress } for each added member
     * ```
     */
    executeAddMembersTransaction({ signer, transaction, ...options }: ExecuteAddMembersTransactionOptions): Promise<{
        digest: string;
        addedMembers: AddedMemberCap[];
    }>;
    /**
     * Update the external SessionKey instance (useful for React context updates)
     * Only works when the client was configured with an external SessionKey
     */
    updateSessionKey(newSessionKey: SessionKey): void;
    /**
     * Force refresh the managed SessionKey (useful for testing or manual refresh)
     * Only works when the client was configured with SessionKeyConfig
     */
    refreshSessionKey(): Promise<SessionKey>;
    /**
     * Execute a create channel transaction
     * @param params - Transaction parameters including signer and optional initial members
     * @returns Transaction digest, channel ID, creator cap ID, and encrypted key
     */
    executeCreateChannelTransaction({ signer, initialMembers, }: {
        initialMembers?: string[];
    } & {
        signer: Signer;
    }): Promise<{
        digest: string;
        channelId: string;
        creatorCapId: string;
        encryptedKeyBytes: Uint8Array<ArrayBuffer>;
    }>;
}
