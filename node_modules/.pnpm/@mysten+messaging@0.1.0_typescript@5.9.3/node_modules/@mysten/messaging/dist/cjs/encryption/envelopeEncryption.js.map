{
  "version": 3,
  "sources": ["../../../src/encryption/envelopeEncryption.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { SessionKey } from '@mysten/seal';\nimport { EncryptedObject } from '@mysten/seal';\nimport { fromHex, isValidSuiObjectId, toHex } from '@mysten/sui/utils';\n\nimport type {\n\tAttachmentMetadata,\n\tDecryptAttachmentDataOpts,\n\tDecryptAttachmentDataResult,\n\tDecryptAttachmentMetadataOpts,\n\tDecryptAttachmentMetadataResult,\n\tDecryptAttachmentOpts,\n\tDecryptAttachmentResult,\n\tDecryptChannelDEKOpts,\n\tDecryptMessageOpts,\n\tDecryptTextOpts,\n\tEncryptAttachmentOpts,\n\tEncryptedAttachmentPayload,\n\tEncryptedMessagePayload,\n\tEncryptedPayload,\n\tEncryptionPrimitives,\n\tEncryptMessageOpts,\n\tEncryptTextOpts,\n\tEnvelopeEncryptionConfig,\n\tGenerateEncryptedChannelDEKopts,\n\tSealApproveContract,\n\tSealConfig,\n\tSymmetricKey,\n} from './types.js';\nimport { WebCryptoPrimitives } from './webCryptoPrimitives.js';\nimport { Transaction } from '@mysten/sui/transactions';\nimport type { MessagingCompatibleClient } from '../types.js';\nimport { SessionKeyManager } from './sessionKeyManager.js';\n\n/**\n * Core envelope encryption service that utilizes Seal\n */\nexport class EnvelopeEncryption {\n\t#suiClient: MessagingCompatibleClient;\n\t#encryptionPrimitives: EncryptionPrimitives;\n\t#sessionKeyManager: SessionKeyManager;\n\t#sealApproveContract: SealApproveContract;\n\t#sealConfig: SealConfig;\n\n\tconstructor(config: EnvelopeEncryptionConfig) {\n\t\tthis.#suiClient = config.suiClient;\n\t\tthis.#sealApproveContract = config.sealApproveContract;\n\t\t// Initialize with defaults if not provided\n\t\tthis.#sealConfig = {\n\t\t\tthreshold: config.sealConfig?.threshold ?? 2,\n\t\t};\n\t\tthis.#encryptionPrimitives = config.encryptionPrimitives ?? WebCryptoPrimitives.getInstance();\n\n\t\tthis.#sessionKeyManager = new SessionKeyManager(\n\t\t\tconfig.sessionKey,\n\t\t\tconfig.sessionKeyConfig,\n\t\t\tthis.#suiClient,\n\t\t\tthis.#sealApproveContract,\n\t\t);\n\t}\n\n\t/**\n\t * Update the external SessionKey instance (useful for React context updates)\n\t */\n\tupdateSessionKey(newSessionKey: SessionKey): void {\n\t\tthis.#sessionKeyManager.updateExternalSessionKey(newSessionKey);\n\t}\n\n\t/**\n\t * Force refresh the managed SessionKey (useful for testing or manual refresh)\n\t */\n\tasync refreshSessionKey(): Promise<SessionKey> {\n\t\treturn this.#sessionKeyManager.refreshManagedSessionKey();\n\t}\n\n\t// ===== Encryption methods =====\n\t/**\n\t * Generate encrypted channel data encryption key\n\t * @param channelId - The channel ID\n\t * @returns Encrypted DEK bytes\n\t */\n\tasync generateEncryptedChannelDEK({\n\t\tchannelId,\n\t}: GenerateEncryptedChannelDEKopts): Promise<Uint8Array<ArrayBuffer>> {\n\t\tif (!isValidSuiObjectId(channelId)) {\n\t\t\tthrow new Error('The channelId provided is not a valid Sui Object ID');\n\t\t}\n\t\t// Generate a new DEK\n\t\tconst dek = await this.#encryptionPrimitives.generateDEK();\n\t\t// Encrypt with Seal before returning\n\t\tconst nonce = this.#encryptionPrimitives.generateNonce();\n\t\tconst sealPolicyBytes = fromHex(channelId); // Using channelId as the policy;\n\t\tconst id = toHex(new Uint8Array([...sealPolicyBytes, ...nonce]));\n\t\tconst { encryptedObject: encryptedDekBytes } = await this.#suiClient.seal.encrypt({\n\t\t\tthreshold: this.#sealConfig.threshold!,\n\t\t\tpackageId: this.#sealApproveContract.packageId,\n\t\t\tid,\n\t\t\tdata: dek,\n\t\t});\n\t\treturn new Uint8Array(encryptedDekBytes);\n\t}\n\n\t/**\n\t * Generate a random nonce\n\t * @returns Random nonce bytes\n\t */\n\tgenerateNonce(): Uint8Array<ArrayBuffer> {\n\t\treturn this.#encryptionPrimitives.generateNonce();\n\t}\n\n\t/**\n\t * Encrypt text message\n\t * @param text - The text to encrypt\n\t * @param channelId - The channel ID\n\t * @param sender - The sender address\n\t * @param encryptedKey - The encrypted symmetric key\n\t * @param memberCapId - The member cap ID\n\t * @returns Encrypted payload with ciphertext and nonce\n\t */\n\tasync encryptText({\n\t\ttext,\n\t\tchannelId,\n\t\tsender,\n\t\tencryptedKey,\n\t\tmemberCapId,\n\t}: EncryptTextOpts): Promise<EncryptedPayload> {\n\t\tconst nonce = this.#encryptionPrimitives.generateNonce();\n\t\tconst dek: SymmetricKey = await this.decryptChannelDEK({\n\t\t\tencryptedKey,\n\t\t\tchannelId,\n\t\t\tmemberCapId,\n\t\t});\n\n\t\tconst ciphertext = await this.#encryptionPrimitives.encryptBytes(\n\t\t\tdek.bytes,\n\t\t\tnonce,\n\t\t\tthis.encryptionAAD(channelId, dek.version, sender),\n\t\t\tnew Uint8Array(new TextEncoder().encode(text)),\n\t\t);\n\t\treturn {\n\t\t\tencryptedBytes: ciphertext,\n\t\t\tnonce,\n\t\t};\n\t}\n\n\t/**\n\t * Decrypt text message\n\t * @param encryptedBytes - The encrypted text bytes\n\t * @param nonce - The encryption nonce\n\t * @param channelId - The channel ID\n\t * @param encryptedKey - The encrypted symmetric key\n\t * @param sender - The sender address\n\t * @param memberCapId - The member cap ID\n\t * @returns Decrypted text string\n\t */\n\tasync decryptText({\n\t\tencryptedBytes: ciphertext,\n\t\tnonce,\n\t\tchannelId,\n\t\tencryptedKey,\n\t\tsender,\n\t\tmemberCapId,\n\t}: DecryptTextOpts): Promise<string> {\n\t\tconst dek: SymmetricKey = await this.decryptChannelDEK({\n\t\t\tencryptedKey,\n\t\t\tchannelId,\n\t\t\tmemberCapId,\n\t\t});\n\n\t\tconst decryptedBytes = await this.#encryptionPrimitives.decryptBytes(\n\t\t\tdek.bytes,\n\t\t\tnonce,\n\t\t\tthis.encryptionAAD(channelId, encryptedKey.version, sender),\n\t\t\tciphertext,\n\t\t);\n\t\treturn new TextDecoder().decode(decryptedBytes);\n\t}\n\n\t/**\n\t * Encrypt attachment file and metadata\n\t * @param file - The file to encrypt\n\t * @param channelId - The channel ID\n\t * @param sender - The sender address\n\t * @param encryptedKey - The encrypted symmetric key\n\t * @param memberCapId - The member cap ID\n\t * @returns Encrypted attachment payload with data and metadata\n\t */\n\tasync encryptAttachment({\n\t\tfile,\n\t\tchannelId,\n\t\tsender,\n\t\tencryptedKey,\n\t\tmemberCapId,\n\t}: EncryptAttachmentOpts): Promise<EncryptedAttachmentPayload> {\n\t\t// Encrypt the attachment Data\n\t\tconst { encryptedBytes: encryptedData, nonce: dataNonce } = await this.encryptAttachmentData({\n\t\t\tfile,\n\t\t\tchannelId,\n\t\t\tsender,\n\t\t\tencryptedKey,\n\t\t\tmemberCapId,\n\t\t});\n\t\t// Encrypt the attachment Metadata\n\t\tconst { encryptedBytes: encryptedMetadata, nonce: metadataNonce } =\n\t\t\tawait this.encryptAttachmentMetadata({\n\t\t\t\tfile,\n\t\t\t\tchannelId,\n\t\t\t\tsender,\n\t\t\t\tencryptedKey,\n\t\t\t\tmemberCapId,\n\t\t\t});\n\n\t\treturn {\n\t\t\tdata: { encryptedBytes: encryptedData, nonce: dataNonce },\n\t\t\tmetadata: { encryptedBytes: encryptedMetadata, nonce: metadataNonce },\n\t\t};\n\t}\n\n\t/**\n\t * Encrypt attachment file data\n\t * @param file - The file to encrypt\n\t * @param channelId - The channel ID\n\t * @param sender - The sender address\n\t * @param encryptedKey - The encrypted symmetric key\n\t * @param memberCapId - The member cap ID\n\t * @returns Encrypted payload with data and nonce\n\t */\n\tasync encryptAttachmentData({\n\t\tfile,\n\t\tchannelId,\n\t\tsender,\n\t\tencryptedKey,\n\t\tmemberCapId,\n\t}: EncryptAttachmentOpts): Promise<EncryptedPayload> {\n\t\tconst dek: SymmetricKey = await this.decryptChannelDEK({\n\t\t\tencryptedKey,\n\t\t\tchannelId,\n\t\t\tmemberCapId,\n\t\t});\n\n\t\tconst nonce = this.generateNonce();\n\n\t\t// Read file as ArrayBuffer\n\t\tconst fileData = await file.arrayBuffer();\n\n\t\t// Encrypt file data\n\t\tconst encryptedData = await this.#encryptionPrimitives.encryptBytes(\n\t\t\tdek.bytes,\n\t\t\tnonce,\n\t\t\tthis.encryptionAAD(channelId, dek.version, sender),\n\t\t\tnew Uint8Array(fileData),\n\t\t);\n\t\treturn { encryptedBytes: encryptedData, nonce };\n\t}\n\n\t/**\n\t * Encrypt attachment metadata\n\t * @param file - The file to get metadata from\n\t * @param channelId - The channel ID\n\t * @param sender - The sender address\n\t * @param encryptedKey - The encrypted symmetric key\n\t * @param memberCapId - The member cap ID\n\t * @returns Encrypted payload with metadata and nonce\n\t */\n\tasync encryptAttachmentMetadata({\n\t\tchannelId,\n\t\tsender,\n\t\tencryptedKey,\n\t\tmemberCapId,\n\t\tfile,\n\t}: EncryptAttachmentOpts): Promise<EncryptedPayload> {\n\t\tconst dek: SymmetricKey = await this.decryptChannelDEK({\n\t\t\tencryptedKey,\n\t\t\tchannelId,\n\t\t\tmemberCapId,\n\t\t});\n\n\t\tconst nonce = this.generateNonce();\n\n\t\t// Extract file metadata\n\t\tconst metadata: AttachmentMetadata = {\n\t\t\tfileName: file.name,\n\t\t\tmimeType: file.type,\n\t\t\tfileSize: file.size,\n\t\t};\n\n\t\t// Encrypt metadata as one piece of data\n\t\tconst metadataStr = JSON.stringify(metadata);\n\t\tconst encryptedMetadata = await this.#encryptionPrimitives.encryptBytes(\n\t\t\tdek.bytes,\n\t\t\tnonce,\n\t\t\tthis.encryptionAAD(channelId, dek.version, sender),\n\t\t\tnew Uint8Array(new TextEncoder().encode(metadataStr)),\n\t\t);\n\n\t\treturn {\n\t\t\tencryptedBytes: encryptedMetadata,\n\t\t\tnonce,\n\t\t};\n\t}\n\n\t/**\n\t * Decrypt attachment metadata\n\t * @param encryptedBytes - The encrypted metadata bytes\n\t * @param nonce - The encryption nonce\n\t * @param channelId - The channel ID\n\t * @param sender - The sender address\n\t * @param encryptedKey - The encrypted symmetric key\n\t * @param memberCapId - The member cap ID\n\t * @returns Decrypted attachment metadata\n\t */\n\tasync decryptAttachmentMetadata({\n\t\tchannelId,\n\t\tsender,\n\t\tencryptedKey,\n\t\tmemberCapId,\n\t\tencryptedBytes,\n\t\tnonce,\n\t}: DecryptAttachmentMetadataOpts): Promise<DecryptAttachmentMetadataResult> {\n\t\tconst dek: SymmetricKey = await this.decryptChannelDEK({\n\t\t\tencryptedKey,\n\t\t\tchannelId,\n\t\t\tmemberCapId,\n\t\t});\n\n\t\t// Decrypt metadata\n\t\tconst decryptedMetadataBytes = await this.#encryptionPrimitives.decryptBytes(\n\t\t\tdek.bytes,\n\t\t\tnonce,\n\t\t\tthis.encryptionAAD(channelId, dek.version, sender),\n\t\t\tencryptedBytes,\n\t\t);\n\t\t// Parse the bytes back to JSON\n\t\tconst metadataStr = new TextDecoder().decode(decryptedMetadataBytes);\n\t\tconst { fileName, mimeType, fileSize } = JSON.parse(metadataStr);\n\n\t\treturn {\n\t\t\tfileName,\n\t\t\tmimeType,\n\t\t\tfileSize,\n\t\t};\n\t}\n\n\t/**\n\t * Decrypt attachment file data\n\t * @param encryptedBytes - The encrypted data bytes\n\t * @param nonce - The encryption nonce\n\t * @param channelId - The channel ID\n\t * @param sender - The sender address\n\t * @param encryptedKey - The encrypted symmetric key\n\t * @param memberCapId - The member cap ID\n\t * @returns Decrypted attachment data\n\t */\n\tasync decryptAttachmentData({\n\t\tchannelId,\n\t\tsender,\n\t\tencryptedKey,\n\t\tmemberCapId,\n\t\tencryptedBytes,\n\t\tnonce,\n\t}: DecryptAttachmentDataOpts): Promise<DecryptAttachmentDataResult> {\n\t\tconst dek: SymmetricKey = await this.decryptChannelDEK({\n\t\t\tencryptedKey,\n\t\t\tchannelId,\n\t\t\tmemberCapId,\n\t\t});\n\t\tconst decryptedData = await this.#encryptionPrimitives.decryptBytes(\n\t\t\tdek.bytes,\n\t\t\tnonce,\n\t\t\tthis.encryptionAAD(channelId, dek.version, sender),\n\t\t\tencryptedBytes,\n\t\t);\n\t\treturn { data: decryptedData };\n\t}\n\n\t/**\n\t * Decrypt attachment file and metadata\n\t * @param data - The encrypted data payload\n\t * @param metadata - The encrypted metadata payload\n\t * @param channelId - The channel ID\n\t * @param sender - The sender address\n\t * @param encryptedKey - The encrypted symmetric key\n\t * @param memberCapId - The member cap ID\n\t * @returns Decrypted attachment with data and metadata\n\t */\n\tasync decryptAttachment({\n\t\tchannelId,\n\t\tsender,\n\t\tencryptedKey,\n\t\tmemberCapId,\n\t\tdata,\n\t\tmetadata,\n\t}: DecryptAttachmentOpts): Promise<DecryptAttachmentResult> {\n\t\t// Decrypt file data\n\t\tconst decryptedData = await this.decryptAttachmentData({\n\t\t\tchannelId,\n\t\t\tsender,\n\t\t\tencryptedKey,\n\t\t\tmemberCapId,\n\t\t\tencryptedBytes: data.encryptedBytes,\n\t\t\tnonce: data.nonce,\n\t\t});\n\n\t\t// Decrypt metadata\n\t\tconst { fileName, mimeType, fileSize } = await this.decryptAttachmentMetadata({\n\t\t\tchannelId,\n\t\t\tsender,\n\t\t\tencryptedKey,\n\t\t\tmemberCapId,\n\t\t\tencryptedBytes: metadata.encryptedBytes,\n\t\t\tnonce: metadata.nonce,\n\t\t});\n\n\t\treturn {\n\t\t\tdata: decryptedData.data,\n\t\t\tfileName,\n\t\t\tmimeType,\n\t\t\tfileSize,\n\t\t};\n\t}\n\n\t/**\n\t * Encrypt message text and attachments\n\t * @param text - The message text\n\t * @param attachments - Optional file attachments\n\t * @param channelId - The channel ID\n\t * @param sender - The sender address\n\t * @param encryptedKey - The encrypted symmetric key\n\t * @param memberCapId - The member cap ID\n\t * @returns Encrypted message payload\n\t */\n\tasync encryptMessage({\n\t\ttext,\n\t\tattachments,\n\t\tchannelId,\n\t\tsender,\n\t\tencryptedKey,\n\t\tmemberCapId,\n\t}: EncryptMessageOpts): Promise<EncryptedMessagePayload> {\n\t\t// Encrypt text\n\t\tconst { encryptedBytes: ciphertext, nonce } = await this.encryptText({\n\t\t\ttext,\n\t\t\tchannelId,\n\t\t\tsender,\n\t\t\tencryptedKey,\n\t\t\tmemberCapId,\n\t\t});\n\n\t\t// If there are no attachments, return early\n\t\tif (!attachments || attachments.length === 0) {\n\t\t\treturn { text: { encryptedBytes: ciphertext, nonce } };\n\t\t}\n\n\t\t// Encrypt attachments in parallel\n\t\tconst encryptedAttachments = await Promise.all(\n\t\t\tattachments.map((file) =>\n\t\t\t\tthis.encryptAttachment({\n\t\t\t\t\tfile,\n\t\t\t\t\tchannelId,\n\t\t\t\t\tsender,\n\t\t\t\t\tencryptedKey,\n\t\t\t\t\tmemberCapId,\n\t\t\t\t}),\n\t\t\t),\n\t\t);\n\n\t\treturn {\n\t\t\ttext: { encryptedBytes: ciphertext, nonce },\n\t\t\tattachments: encryptedAttachments,\n\t\t};\n\t}\n\n\t/**\n\t * Decrypt message text and attachments\n\t * @param ciphertext - The encrypted text bytes\n\t * @param nonce - The encryption nonce\n\t * @param attachments - Optional encrypted attachments\n\t * @param channelId - The channel ID\n\t * @param sender - The sender address\n\t * @param encryptedKey - The encrypted symmetric key\n\t * @param memberCapId - The member cap ID\n\t * @returns Decrypted message with text and attachments\n\t */\n\tasync decryptMessage({\n\t\tciphertext,\n\t\tnonce,\n\t\tattachments,\n\t\tchannelId,\n\t\tsender,\n\t\tencryptedKey,\n\t\tmemberCapId,\n\t}: DecryptMessageOpts): Promise<{ text: string; attachments?: DecryptAttachmentResult[] }> {\n\t\t// Decrypt text\n\t\tconst text = await this.decryptText({\n\t\t\tencryptedBytes: ciphertext,\n\t\t\tnonce,\n\t\t\tchannelId,\n\t\t\tsender,\n\t\t\tencryptedKey,\n\t\t\tmemberCapId,\n\t\t});\n\n\t\t// If there are no attachments, return early\n\t\tif (!attachments || attachments.length === 0) {\n\t\t\treturn { text };\n\t\t}\n\n\t\t// Decrypt attachments in parallel\n\t\tconst decryptedAttachments = await Promise.all(\n\t\t\tattachments.map((attachment) =>\n\t\t\t\tthis.decryptAttachment({\n\t\t\t\t\t...attachment,\n\t\t\t\t\tchannelId,\n\t\t\t\t\tsender,\n\t\t\t\t\tencryptedKey,\n\t\t\t\t\tmemberCapId,\n\t\t\t\t}),\n\t\t\t),\n\t\t);\n\n\t\treturn {\n\t\t\ttext,\n\t\t\tattachments: decryptedAttachments,\n\t\t};\n\t}\n\n\t/**\n\t * Decrypt encrypted channel data encryption key using Seal\n\t * @param encryptedKey - The encrypted symmetric key\n\t * @param channelId - The channel ID\n\t * @param memberCapId - The member cap ID\n\t * @returns Decrypted symmetric key\n\t */\n\tasync decryptChannelDEK({\n\t\tencryptedKey,\n\t\tchannelId,\n\t\tmemberCapId,\n\t}: DecryptChannelDEKOpts): Promise<SymmetricKey> {\n\t\tif (!isValidSuiObjectId(channelId)) {\n\t\t\tthrow new Error('The channelId provided is not a valid Sui Object ID');\n\t\t}\n\t\tif (!isValidSuiObjectId(memberCapId)) {\n\t\t\tthrow new Error('The memberCapId provided is not a valid Sui Object ID');\n\t\t}\n\n\t\t// === Decrypt the cached key ===\n\t\t// Prepare seal_approve ptb\n\n\t\tconst channelIdBytes = EncryptedObject.parse(encryptedKey.encryptedBytes).id;\n\n\t\tconst tx = new Transaction();\n\t\ttx.moveCall({\n\t\t\ttarget: `${this.#sealApproveContract.packageId}::${this.#sealApproveContract.module}::${this.#sealApproveContract.functionName}`,\n\t\t\targuments: [\n\t\t\t\t// Seal Identity Bytes: Channel object ID\n\t\t\t\t// key form: [packageId][channelId][random nonce]\n\t\t\t\ttx.pure.vector('u8', fromHex(channelIdBytes)),\n\t\t\t\t// Channel Object\n\t\t\t\ttx.object(channelId),\n\t\t\t\t// Member Cap Object\n\t\t\t\ttx.object(memberCapId),\n\t\t\t],\n\t\t});\n\t\tconst txBytes = await tx.build({ client: this.#suiClient, onlyTransactionKind: true });\n\t\t// Decrypt using Seal\n\t\t// NOTE: checkLEEncoding is needed for backward compatibility with ciphertexts\n\t\t// created with Seal SDK <0.8.0 (which used little-endian encoding).\n\t\t// See: https://github.com/MystenLabs/ts-sdks/blob/main/packages/seal/CHANGELOG.md#080\n\t\tlet dekBytes: Uint8Array;\n\t\ttry {\n\t\t\tdekBytes = await this.#suiClient.seal.decrypt({\n\t\t\t\tdata: encryptedKey.encryptedBytes,\n\t\t\t\tsessionKey: await this.#sessionKeyManager.getSessionKey(),\n\t\t\t\ttxBytes,\n\t\t\t\tcheckLEEncoding: true, // Support legacy LE-encoded ciphertexts\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tconsole.error('Error decrypting channel DEK', error);\n\t\t\tthrow error;\n\t\t}\n\t\t// const dekBytes = await this.#suiClient.seal.decrypt({\n\t\t// \tdata: encryptedKey.encryptedBytes,\n\t\t// \tsessionKey: await this.getSessionKey(),\n\t\t// \ttxBytes,\n\t\t// });\n\n\t\treturn {\n\t\t\t$kind: 'Unencrypted',\n\t\t\tbytes: new Uint8Array(dekBytes || new Uint8Array()),\n\t\t\tversion: encryptedKey.version,\n\t\t};\n\t}\n\n\t// ===== Private methods =====\n\n\t/**\n\t * Get Additional Authenticated Data for encryption/decryption\n\t * @param channelId - The channel ID\n\t * @param keyVersion - The key version\n\t * @param sender - The sender address\n\t * @returns AAD bytes\n\t */\n\tprivate encryptionAAD(\n\t\tchannelId: string,\n\t\tkeyVersion: number,\n\t\tsender: string,\n\t): Uint8Array<ArrayBuffer> {\n\t\treturn new Uint8Array(new TextEncoder().encode(channelId + keyVersion.toString() + sender));\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
