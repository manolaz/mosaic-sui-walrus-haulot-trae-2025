{
  "version": 3,
  "sources": ["../../src/types.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type {\n\tClientWithExtensions,\n\tExperimental_CoreClient,\n\tExperimental_SuiClientTypes,\n} from '@mysten/sui/experimental';\nimport type { SealClient, SessionKey } from '@mysten/seal';\nimport type { WalrusClient } from '@mysten/walrus';\nimport type { Transaction } from '@mysten/sui/transactions';\nimport type { Signer } from '@mysten/sui/cryptography';\n\nimport type {\n\tAttachmentMetadata,\n\tEncryptedSymmetricKey,\n\tSealApproveContract,\n\tSealConfig,\n\tSessionKeyConfig,\n} from './encryption/types.js';\n\nimport type { MemberCap } from './contracts/sui_stack_messaging/member_cap.js';\nimport type { CreatorCap } from './contracts/sui_stack_messaging/creator_cap.js';\nimport type { StorageAdapter, StorageConfig } from './storage/adapters/storage.js';\nimport type { Channel } from './contracts/sui_stack_messaging/channel.js';\nimport type { Message } from './contracts/sui_stack_messaging/message.js';\n\n// Base configuration shared by all variants\ninterface BaseMessagingClientExtensionOptions {\n\tpackageConfig?: MessagingPackageConfig;\n\t/**\n\t * Seal operation configuration (optional)\n\t * Note: This configures Seal operation parameters, not key servers\n\t * Key servers are configured separately via SealClient.asClientExtension()\n\t */\n\tsealConfig?: SealConfig;\n}\n\n// Storage variants (mutually exclusive)\ntype StorageOptions =\n\t| { storage: (client: MessagingCompatibleClient) => StorageAdapter }\n\t| { walrusStorageConfig: StorageConfig };\n\n// Seal session key variants (mutually exclusive)\ntype SealSessionKeyOptions = { sessionKey: SessionKey } | { sessionKeyConfig: SessionKeyConfig };\n\n// Final type combining all variants with compile-time safety\nexport type MessagingClientExtensionOptions = BaseMessagingClientExtensionOptions &\n\tStorageOptions &\n\tSealSessionKeyOptions;\n\nexport interface MessagingClientOptions {\n\tsuiClient: MessagingCompatibleClient;\n\tstorage: (client: MessagingCompatibleClient) => StorageAdapter;\n\tpackageConfig?: MessagingPackageConfig;\n\tsessionKeyConfig?: SessionKeyConfig;\n\tsessionKey?: SessionKey;\n\tsealConfig?: SealConfig;\n}\n\n// Create Channel Flow interfaces\nexport interface CreateChannelFlowOpts {\n\tcreatorAddress: string;\n\tinitialMemberAddresses?: string[];\n}\n\nexport interface CreateChannelFlowGenerateAndAttachEncryptionKeyOpts {\n\tcreatorMemberCap: (typeof MemberCap)['$inferType'];\n}\n\nexport interface CreateChannelFlowGetGeneratedCapsOpts {\n\tdigest: string; // Transaction digest from the channel creation transaction\n}\n\nexport interface CreateChannelFlow {\n\tbuild: () => Transaction;\n\tgetGeneratedCaps: (opts: CreateChannelFlowGetGeneratedCapsOpts) => Promise<{\n\t\tcreatorCap: (typeof CreatorCap)['$inferType'];\n\t\tcreatorMemberCap: (typeof MemberCap)['$inferType'];\n\t\tadditionalMemberCaps: (typeof MemberCap)['$inferType'][];\n\t}>;\n\tgenerateAndAttachEncryptionKey: (\n\t\topts: CreateChannelFlowGenerateAndAttachEncryptionKeyOpts,\n\t) => Promise<Transaction>;\n\tgetGeneratedEncryptionKey: () => {\n\t\tchannelId: string;\n\t\tencryptedKeyBytes: Uint8Array<ArrayBuffer>;\n\t};\n}\n\n// Add Members interfaces\nexport interface AddMembersOptions {\n\tchannelId: string;\n\tmemberCapId: string;\n\tnewMemberAddresses: string[];\n\tcreatorCapId: string;\n}\n\nexport interface AddMembersTransactionOptions extends AddMembersOptions {\n\ttransaction?: Transaction;\n}\n\nexport interface ExecuteAddMembersTransactionOptions extends AddMembersOptions {\n\ttransaction?: Transaction;\n\tsigner: Signer;\n}\n\nexport interface AddedMemberCap {\n\tmemberCap: (typeof MemberCap)['$inferType'];\n\townerAddress: string;\n}\n\nexport interface MessagingPackageConfig {\n\tpackageId: string;\n\tsealApproveContract?: SealApproveContract;\n}\n\nexport type MessagingCompatibleClient = ClientWithExtensions<{\n\tcore: Experimental_CoreClient;\n\tseal: SealClient;\n\twalrus?: WalrusClient;\n}>;\n\ntype MessagingOwnedObjects = Omit<Experimental_SuiClientTypes.GetOwnedObjectsOptions, 'type'>;\n\nexport type PaginatedResponse<T> = T & {\n\thasNextPage: boolean;\n\tcursor: string | null;\n};\n\nexport type ChannelMembershipsRequest = MessagingOwnedObjects;\n\nexport type ParsedChannelObject = (typeof Channel)['$inferType'];\nexport type ParsedMessageObject = (typeof Message)['$inferType'];\nexport type Membership = { member_cap_id: string; channel_id: string };\n\nexport type ChannelMembershipsResponse = PaginatedResponse<{\n\tmemberships: Membership[];\n}>;\n\nexport type ChannelObjectsByMembershipsResponse = PaginatedResponse<{\n\tchannelObjects: ParsedChannelObject[];\n}>;\n\nexport interface GetChannelObjectsByChannelIdsRequest {\n\tchannelIds: string[];\n\tuserAddress: string; // The address of the user requesting the channel objects (needed for decryption)\n\tmemberCapIds?: string[]; // Optional: member cap IDs for each channel (avoids individual lookups)\n}\n\nexport type ChannelMember = {\n\tmemberAddress: string;\n\tmemberCapId: string;\n};\n\nexport type ChannelMembersResponse = {\n\tmembers: ChannelMember[];\n};\n\nexport type ChannelMessagesEncryptedRequest = Omit<\n\tExperimental_SuiClientTypes.GetDynamicFieldsOptions,\n\t'parentId'\n> & {\n\tchannelId: string;\n};\n\nexport type ChannelMessagesEncryptedResponse = PaginatedResponse<{\n\tmessageObjects: ParsedMessageObject[];\n}>;\n\nexport type ChannelMessagesDecryptedRequest = ChannelMessagesEncryptedRequest & {\n\tencryptedKey: EncryptedSymmetricKey;\n\tmemberCapId: string;\n};\n\nexport interface PollingState {\n\tlastMessageCount: bigint;\n\tlastCursor: bigint | null;\n\tchannelId: string;\n}\n\nexport interface GetLatestMessagesRequest {\n\tchannelId: string;\n\tuserAddress: string; // The address of the user requesting the messages (needed for decryption)\n\tpollingState: PollingState;\n\tlimit?: number; // default: 50\n}\n\nexport interface GetChannelMessagesRequest {\n\tchannelId: string;\n\tuserAddress: string; // The address of the user requesting the messages (needed for decryption)\n\tcursor?: bigint | null; // The message index to start from\n\tlimit?: number; // default: 50\n\tdirection?: 'backward' | 'forward'; // default: 'backward'\n}\n\nexport interface MessagesResponse {\n\tmessages: ParsedMessageObject[];\n\tcursor: bigint | null;\n\thasNextPage: boolean; // true if there are older messages available\n\tdirection: 'backward' | 'forward'; // default: 'backward'\n}\n\nexport interface LazyDecryptAttachmentResult extends AttachmentMetadata {\n\t// The actual data - lazy-loaded via promise\n\tdata: Promise<Uint8Array<ArrayBuffer>>;\n}\n\nexport interface DecryptMessageResult {\n\ttext: string;\n\tsender: string;\n\tcreatedAtMs: string;\n\tattachments?: LazyDecryptAttachmentResult[];\n}\n\n// New types for decrypted data\nexport interface DecryptedMessage {\n\ttext: string;\n\tsender: string;\n\tcreatedAtMs: string;\n\tattachments?: LazyDecryptAttachmentResult[];\n}\n\nexport interface DecryptedChannelObject extends Omit<ParsedChannelObject, 'last_message'> {\n\tlast_message?: DecryptedMessage | null;\n}\n\nexport interface DecryptedMessagesResponse {\n\tmessages: DecryptedMessage[];\n\tcursor: bigint | null;\n\thasNextPage: boolean;\n\tdirection: 'backward' | 'forward';\n}\n\nexport interface DecryptedChannelObjectsByAddressResponse\n\textends Omit<ChannelObjectsByMembershipsResponse, 'channelObjects'> {\n\tchannelObjects: DecryptedChannelObject[];\n}\n"],
  "mappings": ";;;;;;;;;;;;;;AAAA;AAAA;",
  "names": []
}
