{
  "version": 3,
  "sources": ["../../src/client.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport { Transaction } from '@mysten/sui/transactions';\nimport type { TransactionResult } from '@mysten/sui/transactions';\nimport type { Signer } from '@mysten/sui/cryptography';\nimport { deriveDynamicFieldID } from '@mysten/sui/utils';\nimport { bcs } from '@mysten/sui/bcs';\nimport type { Experimental_SuiClientTypes } from '@mysten/sui/experimental';\nimport type { SessionKey } from '@mysten/seal';\n\nimport {\n\t_new as newChannel,\n\taddEncryptedKey,\n\tshare as shareChannel,\n\tsendMessage,\n\taddMembers,\n\tChannel,\n} from './contracts/sui_stack_messaging/channel.js';\n\nimport { _new as newAttachment, Attachment } from './contracts/sui_stack_messaging/attachment.js';\n\nimport type {\n\tAddedMemberCap,\n\tAddMembersOptions,\n\tAddMembersTransactionOptions,\n\tChannelMembershipsRequest,\n\tChannelMembershipsResponse,\n\tChannelMembersResponse,\n\tChannelMember,\n\tCreateChannelFlow,\n\tCreateChannelFlowGetGeneratedCapsOpts,\n\tCreateChannelFlowOpts,\n\tDecryptedChannelObject,\n\tDecryptedChannelObjectsByAddressResponse,\n\tDecryptedMessagesResponse,\n\tDecryptMessageResult,\n\tExecuteAddMembersTransactionOptions,\n\tGetChannelMessagesRequest,\n\tGetChannelObjectsByChannelIdsRequest,\n\tGetLatestMessagesRequest,\n\tLazyDecryptAttachmentResult,\n\tMessagingClientExtensionOptions,\n\tMessagingClientOptions,\n\tMessagingCompatibleClient,\n\tMessagingPackageConfig,\n\tParsedChannelObject,\n\tParsedMessageObject,\n} from './types.js';\nimport {\n\tMAINNET_MESSAGING_PACKAGE_CONFIG,\n\tTESTNET_MESSAGING_PACKAGE_CONFIG,\n\tDEFAULT_SEAL_APPROVE_CONTRACT,\n} from './constants.js';\nimport { MessagingClientError } from './error.js';\nimport type { StorageAdapter } from './storage/adapters/storage.js';\nimport { WalrusStorageAdapter } from './storage/adapters/walrus/walrus.js';\nimport type { EncryptedSymmetricKey, SealConfig } from './encryption/types.js';\nimport { EnvelopeEncryption } from './encryption/envelopeEncryption.js';\n\nimport type { RawTransactionArgument } from './contracts/utils/index.js';\nimport {\n\tCreatorCap,\n\ttransferToSender as transferCreatorCap,\n} from './contracts/sui_stack_messaging/creator_cap.js';\nimport {\n\tMemberCap,\n\ttransferMemberCaps,\n\ttransferToRecipient as transferMemberCap,\n} from './contracts/sui_stack_messaging/member_cap.js';\nimport { none as noneConfig } from './contracts/sui_stack_messaging/config.js';\nimport { Message } from './contracts/sui_stack_messaging/message.js';\n\nexport class SuiStackMessagingClient {\n\t#suiClient: MessagingCompatibleClient;\n\t#packageConfig: MessagingPackageConfig;\n\t#storage: (client: MessagingCompatibleClient) => StorageAdapter;\n\t#envelopeEncryption: EnvelopeEncryption;\n\t#sealConfig: SealConfig;\n\t// TODO: Leave the responsibility of caching to the caller\n\t// #encryptedChannelDEKCache: Map<string, EncryptedSymmetricKey> = new Map(); // channelId --> EncryptedSymmetricKey\n\t// #channelMessagesTableIdCache: Map<string, string> = new Map<string, string>(); // channelId --> messagesTableId\n\n\tprivate constructor(public options: MessagingClientOptions) {\n\t\tthis.#suiClient = options.suiClient;\n\t\tthis.#storage = options.storage;\n\n\t\t// Initialize Seal config with defaults\n\t\tthis.#sealConfig = {\n\t\t\tthreshold: options.sealConfig?.threshold ?? 2, // Default threshold of 2\n\t\t};\n\n\t\t// Auto-detect network from client or use package config\n\t\tif (!options.packageConfig) {\n\t\t\tconst network = this.#suiClient.network;\n\t\t\tswitch (network) {\n\t\t\t\tcase 'testnet':\n\t\t\t\t\tthis.#packageConfig = TESTNET_MESSAGING_PACKAGE_CONFIG;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'mainnet':\n\t\t\t\t\tthis.#packageConfig = MAINNET_MESSAGING_PACKAGE_CONFIG;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t// Fallback to testnet for unrecognized networks\n\t\t\t\t\tthis.#packageConfig = TESTNET_MESSAGING_PACKAGE_CONFIG;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tthis.#packageConfig = options.packageConfig;\n\t\t}\n\n\t\t// Resolve sealApproveContract with defaults (use same packageId as messaging package)\n\t\tconst sealApproveContract = this.#packageConfig.sealApproveContract ?? {\n\t\t\tpackageId: this.#packageConfig.packageId,\n\t\t\t...DEFAULT_SEAL_APPROVE_CONTRACT,\n\t\t};\n\n\t\t// Initialize EnvelopeEncryption directly\n\t\tthis.#envelopeEncryption = new EnvelopeEncryption({\n\t\t\tsuiClient: this.#suiClient,\n\t\t\tsealApproveContract,\n\t\t\tsessionKey: options.sessionKey,\n\t\t\tsessionKeyConfig: options.sessionKeyConfig,\n\t\t\tsealConfig: this.#sealConfig,\n\t\t});\n\t}\n\n\t// TODO: Move to standalone function (pattern used in other Mysten TypeScript SDKs)\n\tstatic experimental_asClientExtension(options: MessagingClientExtensionOptions) {\n\t\treturn {\n\t\t\tname: 'messaging' as const,\n\t\t\tregister: (client: MessagingCompatibleClient) => {\n\t\t\t\tconst sealClient = client.seal;\n\n\t\t\t\tif (!sealClient) {\n\t\t\t\t\tthrow new MessagingClientError('SealClient extension is required for MessagingClient');\n\t\t\t\t}\n\n\t\t\t\t// Check if storage configuration is provided\n\t\t\t\tif (!('storage' in options) && !('walrusStorageConfig' in options)) {\n\t\t\t\t\tthrow new MessagingClientError(\n\t\t\t\t\t\t'Either a custom storage adapter via \"storage\" option or explicit Walrus storage configuration via \"walrusStorageConfig\" option must be provided. Fallback to default Walrus endpoints is not supported.',\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// Auto-detect network from the client or use default package config\n\t\t\t\tlet packageConfig = options.packageConfig;\n\t\t\t\tif (!packageConfig) {\n\t\t\t\t\tconst network = client.network;\n\t\t\t\t\tswitch (network) {\n\t\t\t\t\t\tcase 'testnet':\n\t\t\t\t\t\t\tpackageConfig = TESTNET_MESSAGING_PACKAGE_CONFIG;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mainnet':\n\t\t\t\t\t\t\tpackageConfig = MAINNET_MESSAGING_PACKAGE_CONFIG;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t// Fallback to testnet if network is not recognized\n\t\t\t\t\t\t\tpackageConfig = TESTNET_MESSAGING_PACKAGE_CONFIG;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Handle storage configuration\n\t\t\t\tconst storage =\n\t\t\t\t\t'storage' in options\n\t\t\t\t\t\t? (c: MessagingCompatibleClient) => options.storage(c)\n\t\t\t\t\t\t: (c: MessagingCompatibleClient) => {\n\t\t\t\t\t\t\t\t// WalrusClient is optional - we can use WalrusStorageAdapter without it\n\t\t\t\t\t\t\t\t// In the future, when WalrusClient SDK is used, we can check for its presence and use different logic\n\t\t\t\t\t\t\t\treturn new WalrusStorageAdapter(c, options.walrusStorageConfig);\n\t\t\t\t\t\t\t};\n\n\t\t\t\treturn new SuiStackMessagingClient({\n\t\t\t\t\tsuiClient: client,\n\t\t\t\t\tstorage,\n\t\t\t\t\tpackageConfig,\n\t\t\t\t\tsessionKey: 'sessionKey' in options ? options.sessionKey : undefined,\n\t\t\t\t\tsessionKeyConfig: 'sessionKeyConfig' in options ? options.sessionKeyConfig : undefined,\n\t\t\t\t\tsealConfig: options.sealConfig,\n\t\t\t\t});\n\t\t\t},\n\t\t};\n\t}\n\n\t// ===== Private Helper Methods =====\n\n\t/**\n\t * Get user's member cap ID for a specific channel\n\t * @param userAddress - The user's address\n\t * @param channelId - The channel ID\n\t * @returns Member cap ID\n\t */\n\tasync #getUserMemberCapId(userAddress: string, channelId: string): Promise<string> {\n\t\tlet cursor: string | null = null;\n\t\tlet hasNextPage = true;\n\n\t\twhile (hasNextPage) {\n\t\t\tconst memberships = await this.getChannelMemberships({\n\t\t\t\taddress: userAddress,\n\t\t\t\tcursor,\n\t\t\t});\n\n\t\t\tconst membership = memberships.memberships.find((m) => m.channel_id === channelId);\n\n\t\t\tif (membership) {\n\t\t\t\treturn membership.member_cap_id;\n\t\t\t}\n\n\t\t\tcursor = memberships.cursor;\n\t\t\thasNextPage = memberships.hasNextPage;\n\t\t}\n\n\t\tthrow new MessagingClientError(`User ${userAddress} is not a member of channel ${channelId}`);\n\t}\n\n\t/**\n\t * Get encryption key from channel\n\t * @param channel - The channel object\n\t * @returns Encrypted symmetric key\n\t */\n\tasync #getEncryptionKeyFromChannel(channel: ParsedChannelObject): Promise<EncryptedSymmetricKey> {\n\t\tconst encryptedKeyBytes = channel.encryption_key_history.latest;\n\t\tconst keyVersion = channel.encryption_key_history.latest_version;\n\n\t\treturn {\n\t\t\t$kind: 'Encrypted' as const,\n\t\t\tencryptedBytes: new Uint8Array(encryptedKeyBytes),\n\t\t\tversion: keyVersion,\n\t\t};\n\t}\n\n\t/**\n\t * Decrypt a message (private method)\n\t * @param message - The encrypted message object\n\t * @param channelId - The channel ID\n\t * @param memberCapId - The member cap ID\n\t * @param encryptedKey - The encrypted symmetric key\n\t * @returns Decrypted message with lazy-loaded attachments\n\t */\n\tasync #decryptMessage(\n\t\tmessage: (typeof Message)['$inferType'],\n\t\tchannelId: string,\n\t\tmemberCapId: string,\n\t\tencryptedKey: EncryptedSymmetricKey,\n\t): Promise<DecryptMessageResult> {\n\t\t// 1. Decrypt text\n\t\tconst text = await this.#envelopeEncryption.decryptText({\n\t\t\tencryptedBytes: new Uint8Array(message.ciphertext),\n\t\t\tnonce: new Uint8Array(message.nonce),\n\t\t\tsender: message.sender,\n\t\t\tchannelId,\n\t\t\tmemberCapId,\n\t\t\tencryptedKey,\n\t\t});\n\n\t\t// 2. If no attachments, return early\n\t\tif (!message.attachments || message.attachments.length === 0) {\n\t\t\treturn { text, attachments: [], sender: message.sender, createdAtMs: message.created_at_ms };\n\t\t}\n\n\t\t// 3. Decrypt attachments metadata\n\t\tconst attachmentsMetadata = await Promise.all(\n\t\t\tmessage.attachments.map(async (attachment) => {\n\t\t\t\t// Use the encrypted_metadata field directly - no download needed for metadata\n\t\t\t\tconst metadata = await this.#envelopeEncryption.decryptAttachmentMetadata({\n\t\t\t\t\tencryptedBytes: new Uint8Array(attachment.encrypted_metadata),\n\t\t\t\t\tnonce: new Uint8Array(attachment.metadata_nonce),\n\t\t\t\t\tchannelId,\n\t\t\t\t\tsender: message.sender,\n\t\t\t\t\tencryptedKey,\n\t\t\t\t\tmemberCapId,\n\t\t\t\t});\n\n\t\t\t\treturn {\n\t\t\t\t\tmetadata,\n\t\t\t\t\tattachment, // Keep reference to original attachment\n\t\t\t\t};\n\t\t\t}),\n\t\t);\n\n\t\t// 4. Create lazy-loaded attachmentsData\n\t\tconst lazyAttachmentsDataPromises: LazyDecryptAttachmentResult[] = attachmentsMetadata.map(\n\t\t\t({ metadata, attachment }) => ({\n\t\t\t\t...metadata,\n\t\t\t\tdata: this.#createLazyAttachmentDataPromise({\n\t\t\t\t\tblobRef: attachment.blob_ref,\n\t\t\t\t\tnonce: new Uint8Array(attachment.data_nonce),\n\t\t\t\t\tchannelId,\n\t\t\t\t\tsender: message.sender,\n\t\t\t\t\tencryptedKey,\n\t\t\t\t\tmemberCapId,\n\t\t\t\t}),\n\t\t\t}),\n\t\t);\n\n\t\treturn {\n\t\t\ttext,\n\t\t\tsender: message.sender,\n\t\t\tcreatedAtMs: message.created_at_ms,\n\t\t\tattachments: lazyAttachmentsDataPromises,\n\t\t};\n\t}\n\n\t// ===== Read Path =====\n\n\t/**\n\t * Get channel memberships for a user\n\t * @param request - Pagination and filter options\n\t * @returns Channel memberships with pagination info\n\t */\n\tasync getChannelMemberships(\n\t\trequest: ChannelMembershipsRequest,\n\t): Promise<ChannelMembershipsResponse> {\n\t\tconst memberCapsRes = await this.#suiClient.core.getOwnedObjects({\n\t\t\t...request,\n\t\t\ttype: MemberCap.name.replace('@local-pkg/sui-stack-messaging', this.#packageConfig.packageId),\n\t\t});\n\t\t// Filter out any error objects\n\t\tconst validObjects = memberCapsRes.objects.filter(\n\t\t\t(object): object is Experimental_SuiClientTypes.ObjectResponse => !(object instanceof Error),\n\t\t);\n\n\t\tif (validObjects.length === 0) {\n\t\t\treturn {\n\t\t\t\thasNextPage: memberCapsRes.hasNextPage,\n\t\t\t\tcursor: memberCapsRes.cursor,\n\t\t\t\tmemberships: [],\n\t\t\t};\n\t\t}\n\n\t\t// Get all object contents efficiently\n\t\tconst contents = await this.#getObjectContents(validObjects);\n\n\t\t// Parse all MemberCaps\n\t\tconst memberships = await Promise.all(\n\t\t\tcontents.map(async (content) => {\n\t\t\t\tconst parsedMemberCap = MemberCap.parse(content);\n\t\t\t\treturn { member_cap_id: parsedMemberCap.id.id, channel_id: parsedMemberCap.channel_id };\n\t\t\t}),\n\t\t);\n\n\t\treturn {\n\t\t\thasNextPage: memberCapsRes.hasNextPage,\n\t\t\tcursor: memberCapsRes.cursor,\n\t\t\tmemberships,\n\t\t};\n\t}\n\n\t/**\n\t * Get channel objects for a user (returns decrypted data)\n\t * @param request - Pagination and filter options\n\t * @returns Decrypted channel objects with pagination info\n\t */\n\tasync getChannelObjectsByAddress(\n\t\trequest: ChannelMembershipsRequest,\n\t): Promise<DecryptedChannelObjectsByAddressResponse> {\n\t\tconst membershipsPaginated = await this.getChannelMemberships(request);\n\n\t\t// Deduplicate memberships by channel_id to handle cases where a user has multiple MemberCaps for the same channel\n\t\t// This can occur if duplicate addresses were added during channel creation\n\t\tconst seenChannelIds = new Set<string>();\n\t\tconst deduplicatedMemberships = membershipsPaginated.memberships.filter((m) => {\n\t\t\tif (seenChannelIds.has(m.channel_id)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tseenChannelIds.add(m.channel_id);\n\t\t\treturn true;\n\t\t});\n\n\t\tconst channelObjects = await this.getChannelObjectsByChannelIds({\n\t\t\tchannelIds: deduplicatedMemberships.map((m) => m.channel_id),\n\t\t\tuserAddress: request.address,\n\t\t\tmemberCapIds: deduplicatedMemberships.map((m) => m.member_cap_id),\n\t\t});\n\n\t\treturn {\n\t\t\thasNextPage: membershipsPaginated.hasNextPage,\n\t\t\tcursor: membershipsPaginated.cursor,\n\t\t\tchannelObjects,\n\t\t};\n\t}\n\n\t/**\n\t * Get channel objects by channel IDs (returns decrypted data)\n\t * @param request - Request with channel IDs and user address, and optionally memberCapIds\n\t * @returns Decrypted channel objects\n\t */\n\tasync getChannelObjectsByChannelIds(\n\t\trequest: GetChannelObjectsByChannelIdsRequest,\n\t): Promise<DecryptedChannelObject[]> {\n\t\tconst { channelIds, userAddress, memberCapIds } = request;\n\n\t\tconst channelObjectsRes = await this.#suiClient.core.getObjects({\n\t\t\tobjectIds: channelIds,\n\t\t});\n\n\t\tconst parsedChannels = await Promise.all(\n\t\t\tchannelObjectsRes.objects.map(async (object) => {\n\t\t\t\tif (object instanceof Error || !object.content) {\n\t\t\t\t\tthrow new MessagingClientError(`Failed to parse Channel object: ${object}`);\n\t\t\t\t}\n\t\t\t\treturn Channel.parse(await object.content);\n\t\t\t}),\n\t\t);\n\n\t\t// Decrypt each channel's last_message if it exists\n\t\tconst decryptedChannels = await Promise.all(\n\t\t\tparsedChannels.map(async (channel, index) => {\n\t\t\t\tconst decryptedChannel: DecryptedChannelObject = {\n\t\t\t\t\t...channel,\n\t\t\t\t\tlast_message: null,\n\t\t\t\t};\n\n\t\t\t\t// Decrypt last_message if it exists\n\t\t\t\tif (channel.last_message) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Use provided memberCapId or fetch it\n\t\t\t\t\t\tconst memberCapId =\n\t\t\t\t\t\t\tmemberCapIds?.[index] || (await this.#getUserMemberCapId(userAddress, channel.id.id));\n\t\t\t\t\t\tconst encryptedKey = await this.#getEncryptionKeyFromChannel(channel);\n\t\t\t\t\t\tconst decryptedMessage = await this.#decryptMessage(\n\t\t\t\t\t\t\tchannel.last_message,\n\t\t\t\t\t\t\tchannel.id.id,\n\t\t\t\t\t\t\tmemberCapId,\n\t\t\t\t\t\t\tencryptedKey,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tdecryptedChannel.last_message = decryptedMessage;\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t// If decryption fails, set last_message to null\n\t\t\t\t\t\tconsole.warn(`Failed to decrypt last message for channel ${channel.id.id}:`, error);\n\t\t\t\t\t\tdecryptedChannel.last_message = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn decryptedChannel;\n\t\t\t}),\n\t\t);\n\n\t\treturn decryptedChannels;\n\t}\n\n\t/**\n\t * Get all members of a channel\n\t * @param channelId - The channel ID\n\t * @returns Channel members with addresses and member cap IDs\n\t */\n\tasync getChannelMembers(channelId: string): Promise<ChannelMembersResponse> {\n\t\t// 1. Get the channel object to access the auth structure\n\t\tconst channelObjectsRes = await this.#suiClient.core.getObjects({\n\t\t\tobjectIds: [channelId],\n\t\t});\n\t\tconst channelObject = channelObjectsRes.objects[0];\n\t\tif (channelObject instanceof Error || !channelObject.content) {\n\t\t\tthrow new MessagingClientError(`Failed to parse Channel object: ${channelObject}`);\n\t\t}\n\t\tconst channel = Channel.parse(await channelObject.content);\n\n\t\t// 2. Extract member cap IDs from the auth structure\n\t\tconst memberCapIds = channel.auth.member_permissions.contents.map((entry) => entry.key);\n\n\t\tif (memberCapIds.length === 0) {\n\t\t\treturn { members: [] };\n\t\t}\n\n\t\t// 3. Fetch all MemberCap objects\n\t\tconst memberCapObjects = await this.#suiClient.core.getObjects({\n\t\t\tobjectIds: memberCapIds,\n\t\t});\n\n\t\t// 4. Parse MemberCap objects and extract member addresses\n\t\tconst members: ChannelMember[] = [];\n\t\tfor (const obj of memberCapObjects.objects) {\n\t\t\tif (obj instanceof Error || !obj.content) {\n\t\t\t\tconsole.warn('Failed to fetch MemberCap object:', obj);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tconst memberCap = MemberCap.parse(await obj.content);\n\n\t\t\t\t// Get the owner of the MemberCap object\n\t\t\t\tif (obj.owner) {\n\t\t\t\t\tlet memberAddress: string;\n\t\t\t\t\tif (obj.owner.$kind === 'AddressOwner') {\n\t\t\t\t\t\tmemberAddress = obj.owner.AddressOwner;\n\t\t\t\t\t} else if (obj.owner.$kind === 'ObjectOwner') {\n\t\t\t\t\t\t// For object-owned MemberCaps, we can't easily get the address\n\t\t\t\t\t\t// This is a limitation of the current approach\n\t\t\t\t\t\tconsole.warn('MemberCap is object-owned, skipping:', memberCap.id.id);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.warn('MemberCap has unknown ownership type:', obj.owner);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tmembers.push({\n\t\t\t\t\t\tmemberAddress,\n\t\t\t\t\t\tmemberCapId: memberCap.id.id,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tconsole.warn('Failed to parse MemberCap object:', error);\n\t\t\t}\n\t\t}\n\n\t\treturn { members };\n\t}\n\n\t/**\n\t * Get messages from a channel with pagination (returns decrypted messages)\n\t * @param request - Request parameters including channelId, userAddress, cursor, limit, and direction\n\t * @returns Decrypted messages with pagination info\n\t */\n\tasync getChannelMessages({\n\t\tchannelId,\n\t\tuserAddress,\n\t\tcursor = null,\n\t\tlimit = 50,\n\t\tdirection = 'backward',\n\t}: GetChannelMessagesRequest): Promise<DecryptedMessagesResponse> {\n\t\t// 1. Get channel metadata (we need the raw channel object for metadata, not decrypted)\n\t\tconst channelObjectsRes = await this.#suiClient.core.getObjects({\n\t\t\tobjectIds: [channelId],\n\t\t});\n\t\tconst channelObject = channelObjectsRes.objects[0];\n\t\tif (channelObject instanceof Error || !channelObject.content) {\n\t\t\tthrow new MessagingClientError(`Failed to parse Channel object: ${channelObject}`);\n\t\t}\n\t\tconst channel = Channel.parse(await channelObject.content);\n\n\t\tconst messagesTableId = channel.messages.contents.id.id;\n\t\tconst totalMessagesCount = BigInt(channel.messages_count);\n\n\t\t// 2. Validate inputs\n\t\tif (totalMessagesCount === BigInt(0)) {\n\t\t\treturn this.#createEmptyMessagesResponse(direction);\n\t\t}\n\n\t\tif (cursor !== null && cursor >= totalMessagesCount) {\n\t\t\tthrow new MessagingClientError(\n\t\t\t\t`Cursor ${cursor} is out of bounds. Channel has ${totalMessagesCount} messages.`,\n\t\t\t);\n\t\t}\n\n\t\t// 3. Calculate fetch range based on direction and cursor\n\t\tconst fetchRange = this.#calculateFetchRange({\n\t\t\tcursor,\n\t\t\tlimit,\n\t\t\tdirection,\n\t\t\ttotalMessagesCount,\n\t\t});\n\n\t\t// 4. Handle edge cases\n\t\tif (fetchRange.startIndex >= fetchRange.endIndex) {\n\t\t\treturn this.#createEmptyMessagesResponse(direction);\n\t\t}\n\n\t\t// 5. Fetch and parse messages\n\t\tconst rawMessages = await this.#fetchMessagesInRange(messagesTableId, fetchRange);\n\n\t\t// 6. Decrypt messages\n\t\tconst memberCapId = await this.#getUserMemberCapId(userAddress, channelId);\n\t\tconst encryptedKey = await this.#getEncryptionKeyFromChannel(channel);\n\n\t\tconst decryptedMessages = await Promise.all(\n\t\t\trawMessages.map(async (message) => {\n\t\t\t\ttry {\n\t\t\t\t\treturn await this.#decryptMessage(message, channelId, memberCapId, encryptedKey);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.warn(`Failed to decrypt message in channel ${channelId}:`, error);\n\t\t\t\t\t// Return a placeholder for failed decryption\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttext: '[Failed to decrypt message]',\n\t\t\t\t\t\tsender: message.sender,\n\t\t\t\t\t\tcreatedAtMs: message.created_at_ms,\n\t\t\t\t\t\tattachments: [],\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}),\n\t\t);\n\n\t\t// 7. Determine next pagination\n\t\tconst nextPagination = this.#determineNextPagination({\n\t\t\tfetchRange,\n\t\t\tdirection,\n\t\t\ttotalMessagesCount,\n\t\t});\n\n\t\t// 8. Create response\n\t\treturn {\n\t\t\tmessages: decryptedMessages,\n\t\t\tcursor: nextPagination.cursor,\n\t\t\thasNextPage: nextPagination.hasNextPage,\n\t\t\tdirection,\n\t\t};\n\t}\n\n\t/**\n\t * Get new messages since last polling state (returns decrypted messages)\n\t * @param request - Request with channelId, userAddress, pollingState, and limit\n\t * @returns New decrypted messages since last poll\n\t */\n\tasync getLatestMessages({\n\t\tchannelId,\n\t\tuserAddress,\n\t\tpollingState,\n\t\tlimit = 50,\n\t}: GetLatestMessagesRequest): Promise<DecryptedMessagesResponse> {\n\t\t// 1. Get current channel state to check for new messages\n\t\tconst channelObjectsRes = await this.#suiClient.core.getObjects({\n\t\t\tobjectIds: [channelId],\n\t\t});\n\t\tconst channelObject = channelObjectsRes.objects[0];\n\t\tif (channelObject instanceof Error || !channelObject.content) {\n\t\t\tthrow new MessagingClientError(`Failed to parse Channel object: ${channelObject}`);\n\t\t}\n\t\tconst channel = Channel.parse(await channelObject.content);\n\t\tconst latestMessageCount = BigInt(channel.messages_count);\n\n\t\t// 2. Check if there are new messages since last poll\n\t\tconst newMessagesCount = latestMessageCount - pollingState.lastMessageCount;\n\n\t\tif (newMessagesCount === BigInt(0)) {\n\t\t\t// No new messages - return empty response with same cursor\n\t\t\treturn {\n\t\t\t\tmessages: [],\n\t\t\t\tcursor: pollingState.lastCursor,\n\t\t\t\thasNextPage: pollingState.lastCursor !== null,\n\t\t\t\tdirection: 'backward',\n\t\t\t};\n\t\t}\n\n\t\t// 3. Use unified method to fetch new messages\n\t\t// Limit to the number of new messages or the requested limit, whichever is smaller\n\t\tconst fetchLimit = Math.min(Number(newMessagesCount), limit);\n\n\t\tconst response = await this.getChannelMessages({\n\t\t\tchannelId,\n\t\t\tuserAddress,\n\t\t\tcursor: pollingState.lastCursor,\n\t\t\tlimit: fetchLimit,\n\t\t\tdirection: 'backward',\n\t\t});\n\n\t\treturn response;\n\t}\n\n\t// ===== Write Path =====\n\n\t/**\n\t * Create a channel creation flow\n\t *\n\t * @usage\n\t * ```\n\t * const flow = client.createChannelFlow();\n\t *\n\t * // Step-by-step execution\n\t * // 1. build\n\t * const tx = flow.build();\n\t * // 2. getGeneratedCaps\n\t * const { creatorCap, creatorMemberCap, additionalMemberCaps } = await flow.getGeneratedCaps({ digest });\n\t * // 3. generateAndAttachEncryptionKey\n\t * const { transaction, creatorCap, encryptedKeyBytes } = await flow.generateAndAttachEncryptionKey({ creatorCap, creatorMemberCap });\n\t * // 4. getGeneratedEncryptionKey\n\t * const { channelId, encryptedKeyBytes } = await flow.getGeneratedEncryptionKey({ creatorCap, encryptedKeyBytes });\n\t * ```\n\t *\n\t * @param opts - Options including creator address and initial members\n\t * @returns Channel creation flow with step-by-step methods\n\t */\n\tcreateChannelFlow({\n\t\tcreatorAddress,\n\t\tinitialMemberAddresses,\n\t}: CreateChannelFlowOpts): CreateChannelFlow {\n\t\tconst build = () => {\n\t\t\tconst tx = new Transaction();\n\t\t\tconst config = tx.add(noneConfig());\n\t\t\tconst [channel, creatorCap, creatorMemberCap] = tx.add(newChannel({ arguments: { config } }));\n\n\t\t\t// Add initial members if provided\n\t\t\t// Deduplicate addresses and filter out creator (who already gets a MemberCap automatically)\n\t\t\tconst uniqueAddresses =\n\t\t\t\tinitialMemberAddresses && initialMemberAddresses.length > 0\n\t\t\t\t\t? this.#deduplicateAddresses(initialMemberAddresses, creatorAddress)\n\t\t\t\t\t: [];\n\t\t\tif (initialMemberAddresses && uniqueAddresses.length !== initialMemberAddresses.length) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t'Duplicate addresses or creator address detected in initialMemberAddresses. Creator automatically receives a MemberCap. Using unique non-creator addresses only.',\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tlet memberCaps: RawTransactionArgument<string> | null = null;\n\t\t\tif (uniqueAddresses.length > 0) {\n\t\t\t\tmemberCaps = tx.add(\n\t\t\t\t\taddMembers({\n\t\t\t\t\t\targuments: {\n\t\t\t\t\t\t\tself: channel,\n\t\t\t\t\t\t\tmemberCap: creatorMemberCap,\n\t\t\t\t\t\t\tn: uniqueAddresses.length,\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Share the channel and transfer creator cap\n\t\t\ttx.add(shareChannel({ arguments: { self: channel, creatorCap } }));\n\t\t\t// Transfer MemberCaps\n\t\t\ttx.add(\n\t\t\t\ttransferMemberCap({\n\t\t\t\t\targuments: { cap: creatorMemberCap, creatorCap, recipient: creatorAddress },\n\t\t\t\t}),\n\t\t\t);\n\t\t\tif (memberCaps !== null) {\n\t\t\t\ttx.add(\n\t\t\t\t\ttransferMemberCaps({\n\t\t\t\t\t\targuments: {\n\t\t\t\t\t\t\tmemberAddresses: tx.pure.vector('address', uniqueAddresses),\n\t\t\t\t\t\t\tmemberCaps,\n\t\t\t\t\t\t\tcreatorCap,\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\ttx.add(transferCreatorCap({ arguments: { self: creatorCap } }));\n\n\t\t\treturn tx;\n\t\t};\n\n\t\tconst getGeneratedCaps = async ({ digest }: CreateChannelFlowGetGeneratedCapsOpts) => {\n\t\t\treturn await this.#getGeneratedCaps(digest);\n\t\t};\n\n\t\tconst generateAndAttachEncryptionKey = async ({\n\t\t\tcreatorCap,\n\t\t\tcreatorMemberCap,\n\t\t}: Awaited<ReturnType<typeof getGeneratedCaps>>) => {\n\t\t\t// Generate the encrypted channel DEK\n\t\t\tconst encryptedKeyBytes = await this.#envelopeEncryption.generateEncryptedChannelDEK({\n\t\t\t\tchannelId: creatorCap.channel_id,\n\t\t\t});\n\n\t\t\tconst tx = new Transaction();\n\n\t\t\ttx.add(\n\t\t\t\taddEncryptedKey({\n\t\t\t\t\targuments: {\n\t\t\t\t\t\tself: tx.object(creatorCap.channel_id),\n\t\t\t\t\t\tmemberCap: tx.object(creatorMemberCap.id.id),\n\t\t\t\t\t\tnewEncryptionKeyBytes: tx.pure.vector('u8', encryptedKeyBytes),\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\t);\n\n\t\t\treturn {\n\t\t\t\ttransaction: tx,\n\t\t\t\tcreatorCap,\n\t\t\t\tencryptedKeyBytes,\n\t\t\t};\n\t\t};\n\n\t\tconst getGeneratedEncryptionKey = ({\n\t\t\tcreatorCap,\n\t\t\tencryptedKeyBytes,\n\t\t}: Awaited<ReturnType<typeof generateAndAttachEncryptionKey>>) => {\n\t\t\treturn { channelId: creatorCap.channel_id, encryptedKeyBytes };\n\t\t};\n\n\t\tconst stepResults: {\n\t\t\tbuild?: ReturnType<typeof build>;\n\t\t\tgetGeneratedCaps?: Awaited<ReturnType<typeof getGeneratedCaps>>;\n\t\t\tgenerateAndAttachEncryptionKey?: Awaited<ReturnType<typeof generateAndAttachEncryptionKey>>;\n\t\t\tgetGeneratedEncryptionKey?: never;\n\t\t} = {};\n\n\t\tfunction getResults<T extends keyof typeof stepResults>(\n\t\t\tstep: T,\n\t\t\tcurrent: keyof typeof stepResults,\n\t\t): NonNullable<(typeof stepResults)[T]> {\n\t\t\tif (!stepResults[step]) {\n\t\t\t\tthrow new Error(`${String(step)} must be executed before calling ${String(current)}`);\n\t\t\t}\n\t\t\treturn stepResults[step]!;\n\t\t}\n\n\t\treturn {\n\t\t\tbuild: () => {\n\t\t\t\tif (!stepResults.build) {\n\t\t\t\t\tstepResults.build = build();\n\t\t\t\t}\n\t\t\t\treturn stepResults.build;\n\t\t\t},\n\t\t\tgetGeneratedCaps: async (opts: CreateChannelFlowGetGeneratedCapsOpts) => {\n\t\t\t\tgetResults('build', 'getGeneratedCaps');\n\t\t\t\tstepResults.getGeneratedCaps = await getGeneratedCaps(opts);\n\t\t\t\treturn stepResults.getGeneratedCaps;\n\t\t\t},\n\t\t\tgenerateAndAttachEncryptionKey: async () => {\n\t\t\t\tstepResults.generateAndAttachEncryptionKey = await generateAndAttachEncryptionKey(\n\t\t\t\t\tgetResults('getGeneratedCaps', 'generateAndAttachEncryptionKey'),\n\t\t\t\t);\n\t\t\t\treturn stepResults.generateAndAttachEncryptionKey.transaction;\n\t\t\t},\n\t\t\tgetGeneratedEncryptionKey: () => {\n\t\t\t\treturn getGeneratedEncryptionKey(\n\t\t\t\t\tgetResults('generateAndAttachEncryptionKey', 'getGeneratedEncryptionKey'),\n\t\t\t\t);\n\t\t\t},\n\t\t};\n\t}\n\n\t/**\n\t * Create a send message transaction builder\n\t * @param channelId - The channel ID\n\t * @param memberCapId - The member cap ID\n\t * @param sender - The sender address\n\t * @param message - The message text\n\t * @param encryptedKey - The encrypted symmetric key\n\t * @param attachments - Optional file attachments\n\t * @returns Transaction builder function\n\t */\n\tasync sendMessage(\n\t\tchannelId: string,\n\t\tmemberCapId: string,\n\t\tsender: string,\n\t\tmessage: string,\n\t\tencryptedKey: EncryptedSymmetricKey,\n\t\tattachments?: File[],\n\t) {\n\t\treturn async (tx: Transaction) => {\n\t\t\tconst channel = tx.object(channelId);\n\t\t\tconst memberCap = tx.object(memberCapId);\n\n\t\t\t// Encrypt the message text\n\t\t\tconst { encryptedBytes: ciphertext, nonce: textNonce } =\n\t\t\t\tawait this.#envelopeEncryption.encryptText({\n\t\t\t\t\ttext: message,\n\t\t\t\t\tchannelId,\n\t\t\t\t\tsender,\n\t\t\t\t\tmemberCapId,\n\t\t\t\t\tencryptedKey,\n\t\t\t\t});\n\n\t\t\t// Encrypt and upload attachments\n\t\t\tconst attachmentsVec = await this.#createAttachmentsVec(\n\t\t\t\ttx,\n\t\t\t\tencryptedKey,\n\t\t\t\tchannelId,\n\t\t\t\tmemberCapId,\n\t\t\t\tsender,\n\t\t\t\tattachments,\n\t\t\t);\n\n\t\t\ttx.add(\n\t\t\t\tsendMessage({\n\t\t\t\t\tpackage: this.#packageConfig.packageId,\n\t\t\t\t\targuments: {\n\t\t\t\t\t\tself: channel,\n\t\t\t\t\t\tmemberCap,\n\t\t\t\t\t\tciphertext: tx.pure.vector('u8', ciphertext),\n\t\t\t\t\t\tnonce: tx.pure.vector('u8', textNonce),\n\t\t\t\t\t\tattachments: attachmentsVec,\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\t);\n\t\t};\n\t}\n\n\tasync #createAttachmentsVec(\n\t\ttx: Transaction,\n\t\tencryptedKey: EncryptedSymmetricKey,\n\t\tchannelId: string,\n\t\tmemberCapId: string,\n\t\tsender: string,\n\t\tattachments?: File[],\n\t): Promise<TransactionResult> {\n\t\tconst attachmentType = this.#packageConfig.packageId\n\t\t\t? // todo: this needs better handling - it's needed for the integration tests\n\t\t\t\tAttachment.name.replace('@local-pkg/sui-stack-messaging', this.#packageConfig.packageId)\n\t\t\t: Attachment.name;\n\n\t\tif (!attachments || attachments.length === 0) {\n\t\t\treturn tx.moveCall({\n\t\t\t\tpackage: '0x1',\n\t\t\t\tmodule: 'vector',\n\t\t\t\tfunction: 'empty',\n\t\t\t\targuments: [],\n\t\t\t\ttypeArguments: [attachmentType],\n\t\t\t});\n\t\t}\n\n\t\t// 1. Encrypt all attachment data in parallel\n\t\tconst encryptedDataPayloads = await Promise.all(\n\t\t\tattachments.map(async (file) => {\n\t\t\t\treturn this.#envelopeEncryption.encryptAttachmentData({\n\t\t\t\t\tfile,\n\t\t\t\t\tchannelId,\n\t\t\t\t\tmemberCapId,\n\t\t\t\t\tencryptedKey,\n\t\t\t\t\tsender,\n\t\t\t\t});\n\t\t\t}),\n\t\t);\n\n\t\t// 2. Upload encrypted data to storage in parallel\n\t\tconst attachmentRefs = await this.#storage(this.#suiClient).upload(\n\t\t\tencryptedDataPayloads.map((p) => p.encryptedBytes),\n\t\t\t{ storageType: 'quilts' },\n\t\t);\n\n\t\t// 3. Encrypt all metadata in parallel\n\t\tconst encryptedMetadataPayloads = await Promise.all(\n\t\t\tattachments.map((file) => {\n\t\t\t\treturn this.#envelopeEncryption.encryptAttachmentMetadata({\n\t\t\t\t\tfile,\n\t\t\t\t\tchannelId,\n\t\t\t\t\tmemberCapId,\n\t\t\t\t\tencryptedKey,\n\t\t\t\t\tsender,\n\t\t\t\t});\n\t\t\t}),\n\t\t);\n\n\t\t// 4. Build the move vector for the transaction\n\t\treturn tx.makeMoveVec({\n\t\t\ttype: attachmentType,\n\t\t\telements: attachmentRefs.ids.map((blobRef, i) => {\n\t\t\t\tconst dataNonce = encryptedDataPayloads[i].nonce;\n\t\t\t\tconst metadata = encryptedMetadataPayloads[i];\n\t\t\t\tconst metadataNonce = metadata.nonce;\n\t\t\t\treturn tx.add(\n\t\t\t\t\tnewAttachment({\n\t\t\t\t\t\tpackage: this.#packageConfig.packageId,\n\t\t\t\t\t\targuments: {\n\t\t\t\t\t\t\tblobRef: tx.pure.string(blobRef),\n\t\t\t\t\t\t\tencryptedMetadata: tx.pure.vector('u8', metadata.encryptedBytes),\n\t\t\t\t\t\t\tdataNonce: tx.pure.vector('u8', dataNonce),\n\t\t\t\t\t\t\tmetadataNonce: tx.pure.vector('u8', metadataNonce),\n\t\t\t\t\t\t\tkeyVersion: tx.pure('u32', encryptedKey.version),\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t}),\n\t\t});\n\t}\n\n\t/**\n\t * Execute a send message transaction\n\t * @param params - Transaction parameters including signer, channelId, memberCapId, message, and encryptedKey\n\t * @returns Transaction digest and message ID\n\t */\n\tasync executeSendMessageTransaction({\n\t\tsigner,\n\t\tchannelId,\n\t\tmemberCapId,\n\t\tmessage,\n\t\tattachments,\n\t\tencryptedKey,\n\t}: {\n\t\tchannelId: string;\n\t\tmemberCapId: string;\n\t\tmessage: string;\n\t\tencryptedKey: EncryptedSymmetricKey;\n\t\tattachments?: File[];\n\t} & { signer: Signer }): Promise<{ digest: string; messageId: string }> {\n\t\tconst tx = new Transaction();\n\t\tconst sendMessageTxBuilder = await this.sendMessage(\n\t\t\tchannelId,\n\t\t\tmemberCapId,\n\t\t\tsigner.toSuiAddress(),\n\t\t\tmessage,\n\t\t\tencryptedKey,\n\t\t\tattachments,\n\t\t);\n\t\tawait sendMessageTxBuilder(tx);\n\t\tconst { digest, effects } = await this.#executeTransaction(tx, signer, 'send message', true);\n\n\t\t// Get the created Message object ID\n\t\tconst messageId = effects.changedObjects.find((obj) => obj.idOperation === 'Created')?.id;\n\t\tif (messageId === undefined) {\n\t\t\tthrow new MessagingClientError('Message id not found on the transaction effects');\n\t\t}\n\n\t\treturn { digest, messageId };\n\t}\n\n\t/**\n\t * Add members to a channel\n\t *\n\t * @example\n\t * ```ts\n\t * tx.add(client.addMembers({\n\t *   channelId,\n\t *   memberCapId,\n\t *   newMemberAddresses: ['0xabc...', '0xdef...'],\n\t *   creatorCapId\n\t * }));\n\t * ```\n\t */\n\taddMembers({ channelId, memberCapId, newMemberAddresses, creatorCapId }: AddMembersOptions) {\n\t\treturn async (tx: Transaction) => {\n\t\t\t// Deduplicate addresses\n\t\t\tconst uniqueAddresses = this.#deduplicateAddresses(newMemberAddresses);\n\n\t\t\tif (uniqueAddresses.length !== newMemberAddresses.length) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t'Duplicate addresses detected in newMemberAddresses. Using unique addresses only.',\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (uniqueAddresses.length === 0) {\n\t\t\t\tconsole.warn('No members to add after deduplication.');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst channel = tx.object(channelId);\n\t\t\tconst memberCap = tx.object(memberCapId);\n\t\t\tconst creatorCap = tx.object(creatorCapId);\n\n\t\t\t// Create new member caps\n\t\t\tconst memberCaps = tx.add(\n\t\t\t\taddMembers({\n\t\t\t\t\tpackage: this.#packageConfig.packageId,\n\t\t\t\t\targuments: {\n\t\t\t\t\t\tself: channel,\n\t\t\t\t\t\tmemberCap,\n\t\t\t\t\t\tn: uniqueAddresses.length,\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\t);\n\n\t\t\t// Transfer member caps to the new members\n\t\t\ttx.add(\n\t\t\t\ttransferMemberCaps({\n\t\t\t\t\tpackage: this.#packageConfig.packageId,\n\t\t\t\t\targuments: {\n\t\t\t\t\t\tmemberAddresses: tx.pure.vector('address', uniqueAddresses),\n\t\t\t\t\t\tmemberCaps,\n\t\t\t\t\t\tcreatorCap,\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\t);\n\t\t};\n\t}\n\n\t/**\n\t * Create a transaction that adds members to a channel\n\t *\n\t * @example\n\t * ```ts\n\t * const tx = client.addMembersTransaction({\n\t *   channelId,\n\t *   memberCapId,\n\t *   newMemberAddresses: ['0xabc...', '0xdef...'],\n\t *   creatorCapId\n\t * });\n\t * ```\n\t */\n\taddMembersTransaction({\n\t\ttransaction = new Transaction(),\n\t\t...options\n\t}: AddMembersTransactionOptions) {\n\t\ttransaction.add(this.addMembers(options));\n\t\treturn transaction;\n\t}\n\n\t/**\n\t * Execute a transaction that adds members to a channel\n\t *\n\t * @example\n\t * ```ts\n\t * const { digest, addedMembers } = await client.executeAddMembersTransaction({\n\t *   channelId,\n\t *   memberCapId,\n\t *   newMemberAddresses: ['0xabc...', '0xdef...'],\n\t *   creatorCapId,\n\t *   signer\n\t * });\n\t * // addedMembers contains { memberCap, ownerAddress } for each added member\n\t * ```\n\t */\n\tasync executeAddMembersTransaction({\n\t\tsigner,\n\t\ttransaction,\n\t\t...options\n\t}: ExecuteAddMembersTransactionOptions): Promise<{\n\t\tdigest: string;\n\t\taddedMembers: AddedMemberCap[];\n\t}> {\n\t\tconst tx = transaction ?? new Transaction();\n\t\tconst addMembersTxBuilder = this.addMembers(options);\n\t\tawait addMembersTxBuilder(tx);\n\n\t\tconst { digest, effects } = await this.#executeTransaction(tx, signer, 'add members', true);\n\n\t\t// Get the created MemberCap objects with owner info\n\t\tconst memberCapsWithOwner = await this.#getCreatedObjectsByType({\n\t\t\teffects,\n\t\t\tobjectTypeName: MemberCap.name,\n\t\t\tparseFunction: (content) => MemberCap.parse(content),\n\t\t\terrorMessage: `MemberCap objects not found in transaction effects for transaction (${digest})`,\n\t\t});\n\n\t\t// Extract owner addresses\n\t\tconst addedMembers: AddedMemberCap[] = memberCapsWithOwner.map(({ object, owner }) => {\n\t\t\tlet ownerAddress: string;\n\t\t\tif (owner.$kind === 'AddressOwner') {\n\t\t\t\townerAddress = owner.AddressOwner;\n\t\t\t} else if (owner.$kind === 'ObjectOwner') {\n\t\t\t\townerAddress = owner.ObjectOwner;\n\t\t\t} else if (owner.$kind === 'Shared') {\n\t\t\t\townerAddress = 'Shared';\n\t\t\t} else {\n\t\t\t\townerAddress = 'Immutable';\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tmemberCap: object,\n\t\t\t\townerAddress,\n\t\t\t};\n\t\t});\n\n\t\treturn { digest, addedMembers };\n\t}\n\n\t/**\n\t * Update the external SessionKey instance (useful for React context updates)\n\t * Only works when the client was configured with an external SessionKey\n\t */\n\tupdateSessionKey(newSessionKey: SessionKey): void {\n\t\tthis.#envelopeEncryption.updateSessionKey(newSessionKey);\n\t}\n\n\t/**\n\t * Force refresh the managed SessionKey (useful for testing or manual refresh)\n\t * Only works when the client was configured with SessionKeyConfig\n\t */\n\tasync refreshSessionKey(): Promise<SessionKey> {\n\t\treturn this.#envelopeEncryption.refreshSessionKey();\n\t}\n\n\t/**\n\t * Execute a create channel transaction\n\t * @param params - Transaction parameters including signer and optional initial members\n\t * @returns Transaction digest, channel ID, creator cap ID, and encrypted key\n\t */\n\tasync executeCreateChannelTransaction({\n\t\tsigner,\n\t\tinitialMembers,\n\t}: {\n\t\tinitialMembers?: string[];\n\t} & { signer: Signer }): Promise<{\n\t\tdigest: string;\n\t\tchannelId: string;\n\t\tcreatorCapId: string;\n\t\tencryptedKeyBytes: Uint8Array<ArrayBuffer>;\n\t}> {\n\t\tconst flow = this.createChannelFlow({\n\t\t\tcreatorAddress: signer.toSuiAddress(),\n\t\t\tinitialMemberAddresses: initialMembers,\n\t\t});\n\n\t\t// Step 1: Build and execute the channel creation transaction\n\t\tconst channelTx = flow.build();\n\t\tconst { digest: channelDigest } = await this.#executeTransaction(\n\t\t\tchannelTx,\n\t\t\tsigner,\n\t\t\t'create channel',\n\t\t);\n\n\t\t// Step 2: Get the creator cap from the transaction\n\t\tconst {\n\t\t\tcreatorCap,\n\t\t\tcreatorMemberCap,\n\t\t\tadditionalMemberCaps: _,\n\t\t} = await flow.getGeneratedCaps({\n\t\t\tdigest: channelDigest,\n\t\t});\n\n\t\t// Step 3: Generate and attach encryption key\n\t\tconst attachKeyTx = await flow.generateAndAttachEncryptionKey({ creatorMemberCap });\n\t\tconst { digest: keyDigest } = await this.#executeTransaction(\n\t\t\tattachKeyTx,\n\t\t\tsigner,\n\t\t\t'attach encryption key',\n\t\t);\n\n\t\t// Step 4: Get the encrypted key bytes\n\t\tconst { channelId, encryptedKeyBytes } = flow.getGeneratedEncryptionKey();\n\n\t\treturn { digest: keyDigest, creatorCapId: creatorCap.id.id, channelId, encryptedKeyBytes };\n\t}\n\n\t// ===== Private Methods =====\n\tasync #executeTransaction(\n\t\ttransaction: Transaction,\n\t\tsigner: Signer,\n\t\taction: string,\n\t\twaitForTransaction: boolean = true,\n\t) {\n\t\ttransaction.setSenderIfNotSet(signer.toSuiAddress());\n\n\t\tconst { digest, effects } = await signer.signAndExecuteTransaction({\n\t\t\ttransaction,\n\t\t\tclient: this.#suiClient,\n\t\t});\n\n\t\tif (effects?.status.error) {\n\t\t\tthrow new MessagingClientError(`Failed to ${action} (${digest}): ${effects?.status.error}`);\n\t\t}\n\n\t\tif (waitForTransaction) {\n\t\t\tawait this.#suiClient.core.waitForTransaction({\n\t\t\t\tdigest,\n\t\t\t});\n\t\t}\n\n\t\treturn { digest, effects };\n\t}\n\n\tasync #getGeneratedCaps(digest: string) {\n\t\tconst {\n\t\t\ttransaction: { effects },\n\t\t} = await this.#suiClient.core.waitForTransaction({\n\t\t\tdigest,\n\t\t});\n\n\t\t// Get CreatorCap\n\t\tconst creatorCapsWithOwner = await this.#getCreatedObjectsByType({\n\t\t\teffects,\n\t\t\tobjectTypeName: CreatorCap.name,\n\t\t\tparseFunction: (content) => CreatorCap.parse(content),\n\t\t\terrorMessage: `CreatorCap object not found in transaction effects for transaction (${digest})`,\n\t\t});\n\n\t\tif (creatorCapsWithOwner.length === 0) {\n\t\t\tthrow new MessagingClientError(\n\t\t\t\t`CreatorCap object not found in transaction effects for transaction (${digest})`,\n\t\t\t);\n\t\t}\n\n\t\tconst { object: creatorCap, owner: creatorCapOwner } = creatorCapsWithOwner[0];\n\n\t\t// Get all MemberCaps with owner info\n\t\tconst allMemberCapsWithOwner = await this.#getCreatedObjectsByType({\n\t\t\teffects,\n\t\t\tobjectTypeName: MemberCap.name,\n\t\t\tparseFunction: (content) => MemberCap.parse(content),\n\t\t\terrorMessage: `MemberCap objects not found in transaction effects for transaction (${digest})`,\n\t\t});\n\n\t\t// Find the creator's member cap (same owner as CreatorCap)\n\t\tconst creatorMemberCapWithOwner = allMemberCapsWithOwner.find(\n\t\t\t({ owner }) =>\n\t\t\t\towner.$kind === 'AddressOwner' &&\n\t\t\t\tcreatorCapOwner.$kind === 'AddressOwner' &&\n\t\t\t\towner.AddressOwner === creatorCapOwner.AddressOwner,\n\t\t);\n\n\t\tif (!creatorMemberCapWithOwner) {\n\t\t\tthrow new MessagingClientError(\n\t\t\t\t`CreatorMemberCap object not found in transaction effects for transaction (${digest})`,\n\t\t\t);\n\t\t}\n\n\t\tconst creatorMemberCap = creatorMemberCapWithOwner.object;\n\n\t\t// Filter out the creator's member cap from additional member caps\n\t\tconst additionalMemberCaps = allMemberCapsWithOwner\n\t\t\t.filter((item) => item.object.id.id !== creatorMemberCap.id.id)\n\t\t\t.map((item) => item.object);\n\n\t\treturn {\n\t\t\tcreatorCap,\n\t\t\tcreatorMemberCap,\n\t\t\tadditionalMemberCaps,\n\t\t};\n\t}\n\n\t/**\n\t * Get created objects of a specific type from transaction effects\n\t * @param effects - Transaction effects\n\t * @param objectTypeName - The object type name (e.g., MemberCap.name)\n\t * @param parseFunction - Function to parse the object content\n\t * @param errorMessage - Error message if objects not found\n\t * @returns Array of parsed objects with owner information\n\t */\n\tasync #getCreatedObjectsByType<T>({\n\t\teffects,\n\t\tobjectTypeName,\n\t\tparseFunction,\n\t\terrorMessage,\n\t}: {\n\t\teffects: Experimental_SuiClientTypes.TransactionEffects;\n\t\tobjectTypeName: string;\n\t\tparseFunction: (content: Uint8Array) => T;\n\t\terrorMessage: string;\n\t}): Promise<Array<{ object: T; owner: Experimental_SuiClientTypes.ObjectOwner }>> {\n\t\tconst objectType = objectTypeName.replace(\n\t\t\t'@local-pkg/sui-stack-messaging',\n\t\t\tthis.#packageConfig.packageId,\n\t\t);\n\n\t\tconst createdObjectIds = effects.changedObjects\n\t\t\t.filter((object) => object.idOperation === 'Created' && object.outputState !== 'DoesNotExist')\n\t\t\t.map((object) => object.id);\n\n\t\tconst createdObjects = await this.#suiClient.core.getObjects({\n\t\t\tobjectIds: createdObjectIds,\n\t\t});\n\n\t\tconst matchingObjects = createdObjects.objects.filter(\n\t\t\t(object) => !(object instanceof Error) && object.type === objectType,\n\t\t);\n\n\t\tconst parsedObjectsWithOwner = await Promise.all(\n\t\t\tmatchingObjects.map(async (objectResponse) => {\n\t\t\t\tif (objectResponse instanceof Error || !objectResponse.content) {\n\t\t\t\t\tthrow new MessagingClientError(errorMessage);\n\t\t\t\t}\n\t\t\t\tconst parsedObject = parseFunction(await objectResponse.content);\n\t\t\t\treturn { object: parsedObject, owner: objectResponse.owner! };\n\t\t\t}),\n\t\t);\n\t\treturn parsedObjectsWithOwner;\n\t}\n\n\t/**\n\t * Deduplicate addresses and optionally filter out an excluded address\n\t * @param addresses - Array of addresses to deduplicate\n\t * @param excludeAddress - Optional address to filter out\n\t * @returns Array of unique addresses, excluding the excluded address if provided\n\t */\n\t#deduplicateAddresses(addresses: string[], excludeAddress?: string): string[] {\n\t\tconst uniqueAddresses = [...new Set(addresses)];\n\t\treturn excludeAddress\n\t\t\t? uniqueAddresses.filter((addr) => addr !== excludeAddress)\n\t\t\t: uniqueAddresses;\n\t}\n\n\t// Derive the message IDs from the given range\n\t// Note: messages = TableVec<Message>\n\t// --> TableVec{contents: Table<u64, Message>}\n\t#deriveMessageIDsFromRange(messagesTableId: string, startIndex: bigint, endIndex: bigint) {\n\t\tconst messageIDs: string[] = [];\n\n\t\tfor (let i = startIndex; i < endIndex; i++) {\n\t\t\tmessageIDs.push(deriveDynamicFieldID(messagesTableId, 'u64', bcs.U64.serialize(i).toBytes()));\n\t\t}\n\n\t\treturn messageIDs;\n\t}\n\n\t// Parse the message objects response\n\t// Note: the given message objects response\n\t// is in the form of dynamic_field::Field<u64, Message>\n\tasync #parseMessageObjects(\n\t\tmessageObjects: Experimental_SuiClientTypes.GetObjectsResponse,\n\t): Promise<ParsedMessageObject[]> {\n\t\tconst DynamicFieldMessage = bcs.struct('DynamicFieldMessage', {\n\t\t\tid: bcs.Address, // UID is represented as an address\n\t\t\tname: bcs.U64, // the key (message index)\n\t\t\tvalue: Message, // the actual Message\n\t\t});\n\n\t\tconst parsedMessageObjects = await Promise.all(\n\t\t\tmessageObjects.objects.map(async (object) => {\n\t\t\t\tif (object instanceof Error || !object.content) {\n\t\t\t\t\tthrow new MessagingClientError(`Failed to parse message object: ${object}`);\n\t\t\t\t}\n\t\t\t\tconst content = await object.content;\n\t\t\t\t// Parse the dynamic field wrapper\n\t\t\t\tconst dynamicField = DynamicFieldMessage.parse(content);\n\n\t\t\t\t// Extract the actual Message from the value field\n\t\t\t\treturn dynamicField.value;\n\t\t\t}),\n\t\t);\n\n\t\treturn parsedMessageObjects;\n\t}\n\n\tasync #createLazyAttachmentDataPromise({\n\t\tchannelId,\n\t\tmemberCapId,\n\t\tsender,\n\t\tencryptedKey,\n\t\tblobRef,\n\t\tnonce,\n\t}: {\n\t\tchannelId: string;\n\t\tmemberCapId: string;\n\t\tsender: string;\n\t\tencryptedKey: EncryptedSymmetricKey;\n\t\tblobRef: string;\n\t\tnonce: Uint8Array;\n\t}): Promise<Uint8Array<ArrayBuffer>> {\n\t\tconst downloadAndDecrypt = async (): Promise<Uint8Array<ArrayBuffer>> => {\n\t\t\t// Download the encrypted data\n\t\t\tconst [encryptedData] = await this.#storage(this.#suiClient).download([blobRef]);\n\n\t\t\t// Decrypt the data\n\t\t\tconst decryptedData = await this.#envelopeEncryption.decryptAttachmentData({\n\t\t\t\tencryptedBytes: new Uint8Array(encryptedData),\n\t\t\t\tnonce: new Uint8Array(nonce),\n\t\t\t\tchannelId,\n\t\t\t\tmemberCapId,\n\t\t\t\tsender,\n\t\t\t\tencryptedKey,\n\t\t\t});\n\n\t\t\treturn decryptedData.data;\n\t\t};\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tdownloadAndDecrypt().then(resolve).catch(reject);\n\t\t});\n\t}\n\n\t/**\n\t * Calculate the range of message indices to fetch\n\t */\n\t#calculateFetchRange({\n\t\tcursor,\n\t\tlimit,\n\t\tdirection,\n\t\ttotalMessagesCount,\n\t}: {\n\t\tcursor: bigint | null;\n\t\tlimit: number;\n\t\tdirection: 'backward' | 'forward';\n\t\ttotalMessagesCount: bigint;\n\t}): { startIndex: bigint; endIndex: bigint } {\n\t\tconst limitBigInt = BigInt(limit);\n\n\t\tif (direction === 'backward') {\n\t\t\t// Fetch messages in descending order (newest first)\n\t\t\tif (cursor === null) {\n\t\t\t\t// First request - get latest messages\n\t\t\t\tconst startIndex =\n\t\t\t\t\ttotalMessagesCount > limitBigInt ? totalMessagesCount - limitBigInt : BigInt(0);\n\t\t\t\treturn {\n\t\t\t\t\tstartIndex,\n\t\t\t\t\tendIndex: totalMessagesCount,\n\t\t\t\t};\n\t\t\t}\n\t\t\t// Subsequent requests - get older messages\n\t\t\tconst endIndex = cursor; // Cursor is exclusive in backward direction\n\t\t\tconst startIndex = endIndex > limitBigInt ? endIndex - limitBigInt : BigInt(0);\n\t\t\treturn {\n\t\t\t\tstartIndex,\n\t\t\t\tendIndex,\n\t\t\t};\n\t\t}\n\t\t// Fetch messages in ascending order (oldest first)\n\t\tif (cursor === null) {\n\t\t\t// First request - get oldest messages\n\t\t\tconst endIndex = totalMessagesCount > limitBigInt ? limitBigInt : totalMessagesCount;\n\t\t\treturn {\n\t\t\t\tstartIndex: BigInt(0),\n\t\t\t\tendIndex,\n\t\t\t};\n\t\t}\n\t\t// Subsequent requests - get newer messages\n\t\tconst startIndex = cursor + BigInt(1); // Cursor is inclusive in forward direction\n\t\tconst endIndex =\n\t\t\tstartIndex + limitBigInt > totalMessagesCount ? totalMessagesCount : startIndex + limitBigInt;\n\t\treturn {\n\t\t\tstartIndex,\n\t\t\tendIndex,\n\t\t};\n\t}\n\n\t/**\n\t * Fetch messages in the specified range\n\t */\n\tasync #fetchMessagesInRange(\n\t\tmessagesTableId: string,\n\t\trange: { startIndex: bigint; endIndex: bigint },\n\t): Promise<ParsedMessageObject[]> {\n\t\tconst messageIds = this.#deriveMessageIDsFromRange(\n\t\t\tmessagesTableId,\n\t\t\trange.startIndex,\n\t\t\trange.endIndex,\n\t\t);\n\n\t\tif (messageIds.length === 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst messageObjects = await this.#suiClient.core.getObjects({ objectIds: messageIds });\n\t\treturn await this.#parseMessageObjects(messageObjects);\n\t}\n\n\t/**\n\t * Create a messages response with pagination info\n\t */\n\t#determineNextPagination({\n\t\tfetchRange,\n\t\tdirection,\n\t\ttotalMessagesCount,\n\t}: {\n\t\tfetchRange: { startIndex: bigint; endIndex: bigint };\n\t\tdirection: 'backward' | 'forward';\n\t\ttotalMessagesCount: bigint;\n\t}): { cursor: bigint | null; hasNextPage: boolean } {\n\t\t// Determine next cursor and hasNextPage based on direction\n\t\tlet nextCursor: bigint | null = null;\n\t\tlet hasNextPage = false;\n\n\t\tif (direction === 'backward') {\n\t\t\t// For backward direction, cursor points to the oldest message we fetched (exclusive)\n\t\t\tnextCursor = fetchRange.startIndex > BigInt(0) ? fetchRange.startIndex : null;\n\t\t\thasNextPage = fetchRange.startIndex > BigInt(0);\n\t\t} else {\n\t\t\t// For forward direction, cursor points to the newest message we fetched (inclusive)\n\t\t\tnextCursor =\n\t\t\t\tfetchRange.endIndex < totalMessagesCount ? fetchRange.endIndex - BigInt(1) : null;\n\t\t\thasNextPage = fetchRange.endIndex < totalMessagesCount;\n\t\t}\n\n\t\treturn {\n\t\t\tcursor: nextCursor,\n\t\t\thasNextPage,\n\t\t};\n\t}\n\n\t/**\n\t * Create an empty messages response\n\t */\n\t#createEmptyMessagesResponse(direction: 'backward' | 'forward'): DecryptedMessagesResponse {\n\t\treturn {\n\t\t\tmessages: [],\n\t\t\tcursor: null,\n\t\t\thasNextPage: false,\n\t\t\tdirection,\n\t\t};\n\t}\n\t/**\n\t * Helper method to get object contents, handling both SuiClient and SuiGrpcClient\n\t */\n\tasync #getObjectContents(\n\t\tobjects: Experimental_SuiClientTypes.ObjectResponse[],\n\t): Promise<Uint8Array[]> {\n\t\t// First, try to get all contents directly (works for SuiClient)\n\t\tconst contentPromises = objects.map(async (object) => {\n\t\t\ttry {\n\t\t\t\treturn await object.content;\n\t\t\t} catch (error) {\n\t\t\t\t// If this is the gRPC error, we'll handle it below\n\t\t\t\tif (\n\t\t\t\t\terror instanceof Error &&\n\t\t\t\t\terror.message.includes('GRPC does not return object contents')\n\t\t\t\t) {\n\t\t\t\t\treturn null; // Mark for batch fetching\n\t\t\t\t}\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t});\n\n\t\tconst contents = await Promise.all(contentPromises);\n\n\t\t// Check if any failed with the gRPC error\n\t\tconst needsBatchFetch = contents.some((content) => content === null);\n\n\t\tif (needsBatchFetch) {\n\t\t\t// Batch fetch all objects that need content\n\t\t\tconst objectIds = objects.map((obj) => obj.id);\n\t\t\tconst objectResponses = await this.#suiClient.core.getObjects({ objectIds });\n\n\t\t\t// Map the results back to the original order and await the content\n\t\t\tconst batchContents = await Promise.all(\n\t\t\t\tobjectResponses.objects.map(async (obj) => {\n\t\t\t\t\tif (obj instanceof Error || !obj.content) {\n\t\t\t\t\t\tthrow new MessagingClientError(`Failed to fetch object content: ${obj}`);\n\t\t\t\t\t}\n\t\t\t\t\treturn await obj.content;\n\t\t\t\t}),\n\t\t\t);\n\n\t\t\treturn batchContents;\n\t\t}\n\n\t\t// Filter out null values and return\n\t\treturn contents.filter((content): content is Uint8Array => content !== null);\n\t}\n}\n"],
  "mappings": "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",
  "names": ["noneConfig", "newChannel", "shareChannel", "transferMemberCap", "transferCreatorCap", "newAttachment", "startIndex", "endIndex"]
}
